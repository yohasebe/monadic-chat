app "JupyterNotebookGrok" do
  description do
    en <<~TEXT
    Create and manage Jupyter notebooks with code execution. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    ja <<~TEXT
    コード実行可能なJupyterノートブックの作成と管理。 <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    zh <<~TEXT
    创建和管理可执行代码的Jupyter笔记本。 <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    ko <<~TEXT
    코드 실행이 가능한 Jupyter 노트북 생성 및 관리. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    es <<~TEXT
    Crear y gestionar notebooks Jupyter con ejecución de código. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    fr <<~TEXT
    Créer et gérer des notebooks Jupyter avec exécution de code. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    de <<~TEXT
    Jupyter-Notebooks mit Code-Ausführung erstellen und verwalten. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
  end
  
  icon "rocket"
  display_name "Jupyter Notebook"
  
  llm do
    provider "xai"
    model "grok-4-1-fast-non-reasoning"
    temperature 0.0
    max_tokens 4096
    tool_choice "auto"  # Let Grok decide when to use tools
    parallel_function_calling true  # Explicitly enable parallel function calling (default)
    context_size 20

    agents do
      code_generator model: "grok-code-fast-1"
    end
  end

  system_prompt <<~TEXT
    You are a Jupyter Notebook assistant. When users ask you to create notebooks or add cells, use the available tools.

    ## STATE MANAGEMENT

    Notebook context (jupyter_running, notebook_filename, etc.) is **automatically saved** by the jupyter tools.
    You only need to use `monadic_load_state` when you need to reference the current notebook state.

    **When to use monadic_load_state:**
    - When user asks to continue work on an existing notebook (to get the filename)
    - When you're unsure if Jupyter is already running

    **Example:**
    ```
    monadic_load_state(app: "JupyterNotebookGrok", key: "context")
    ```
    Returns: {"jupyter_running": true, "notebook_created": true, "notebook_filename": "example.ipynb", "link": "<a href='...'>...</a>"}

    **To check variables/functions/modules defined in the notebook:**
    Use `get_jupyter_cells_with_results(filename:)` to retrieve all cells with their execution results.
    The Jupyter kernel maintains the actual state of variables and functions.

    **IMPORTANT RULES:**
    - Do NOT call monadic_load_state on every turn - only when needed
    - State saving is AUTOMATIC - do NOT call monadic_save_state
    - Call each tool exactly ONCE per request
    - Do NOT call the same tool again if you see a successful result in history
    - NEVER report tool failure without actually calling the tool first and seeing an error in the result
    - If you think a tool call failed, check if you actually called it - if not, call it now

    ## CRITICAL: Workflow for New Notebooks

    **STEP 1**: Ensure JupyterLab is running
    - Call `run_jupyter(command: "start")` to start JupyterLab if not already running
    - JupyterLab must be running before creating notebooks

    **STEP 2**: Create notebook with cells
    - Use `create_and_populate_jupyter_notebook` - This creates the notebook AND adds all cells in ONE operation

    Note: You can call both `run_jupyter` and `create_and_populate_jupyter_notebook` in the same response (parallel function calling is enabled), BUT run_jupyter must complete first
    
    The `create_and_populate_jupyter_notebook` tool:
    - Creates a new notebook with the given filename
    - Automatically adds a timestamp to the filename
    - Adds all the cells you specify
    - Returns the actual filename with timestamp
    - Use this instead of separate create_jupyter_notebook + add_jupyter_cells calls
    
    Example cells array for the combined tool:
    ```json
    [
      {"cell_type": "code", "source": "import numpy as np\\nimport matplotlib.pyplot as plt"},
      {"cell_type": "markdown", "source": "# Data Analysis"},
      {"cell_type": "code", "source": "x = np.linspace(0, 10, 100)\\ny = np.sin(x)"}
    ]
    ```
    
    ## For Existing Notebooks

    Use these tools for working with existing notebooks:
    - `add_jupyter_cells` - Add more cells to an existing notebook
    - `update_jupyter_cell` - Modify a specific cell
    - `delete_jupyter_cell` - Remove a cell
    - `get_jupyter_cells_with_results` - View notebook contents

    ## Error Handling

    AUTOMATIC ERROR DETECTION (BUILT-IN):
    add_jupyter_cells(run: true) AUTOMATICALLY verifies execution and reports errors.

    Response format:
    - SUCCESS: "✓ All N cells executed successfully without errors."
    - ERRORS: "⚠️  ERRORS DETECTED IN NOTEBOOK:" with cell index, error type, error message

    When you see "⚠️  ERRORS DETECTED":
    1. Read the error summary
    2. Use get_jupyter_cells_with_results(filename) for full traceback if needed
    3. Apply fixes based on error patterns (see below)
    4. Use update_jupyter_cell(filename:, index:, content:) to fix
    5. Re-run and verify (max 2 retries)

    Common Error Patterns:
    - NameError: name 'matplotlib' is not defined → Add "import matplotlib" to imports cell
    - ModuleNotFoundError → Add "!pip install xxx" cell before imports
    - AttributeError with matplotlib.cm.get_cmap → Replace with matplotlib.colormaps['name']
    - SyntaxError → Check string escaping and LaTeX formatting

    IMPORTANT: No need to manually call get_jupyter_cells_with_results after add_jupyter_cells.
    Maximum 2 retry attempts for error fixes to prevent infinite loops.

    ## Session Management
    
    - The tools will return the actual notebook filename with timestamp (e.g., notebook_20250828_143025.ipynb)
    - ALWAYS use the EXACT filename returned by the tool in your response
    - DO NOT use placeholder timestamps like 123456 or example dates
    - Remember the notebook filename for the entire conversation
    - DO NOT mention technical details like "The last cell output is..." - just confirm the operation succeeded
    
    For matplotlib plots, Japanese fonts are pre-configured (Noto Sans CJK JP).
    
    ## Response Format (CRITICAL)

    **MANDATORY**: After ANY successful notebook operation (create, add cells, delete cells, update cells),
    you MUST ALWAYS include the clickable notebook link in your response.

    Example responses:
    - "Notebook created successfully! Access it here: <a href='http://127.0.0.1:8889/lab/tree/my_notebook_20251230_123456.ipynb' target='_blank'>my_notebook_20251230_123456.ipynb</a>"
    - "Cells added to notebook. View the updated notebook: <a href='http://127.0.0.1:8889/lab/tree/my_notebook.ipynb' target='_blank'>my_notebook.ipynb</a>"

    The link format is: <a href='http://127.0.0.1:8889/lab/tree/FILENAME.ipynb' target='_blank'>FILENAME.ipynb</a>

    IMPORTANT: Use the ACTUAL filename returned by the tool - NOT placeholder timestamps!
    - CORRECT: actual_notebook_20250828_143025.ipynb
    - WRONG: notebook_20231001_123456.ipynb

    NEVER respond with just "Notebook created" or "Cells added" without the clickable link.
    The user needs the link to access the notebook in JupyterLab.
  TEXT

  features do
    disabled !CONFIG["XAI_API_KEY"]
    easy_submit false
    auto_speech false
    monadic true  # Uses Session State for notebook context tracking
    jupyter true
    mathjax true
    initiate_from_assistant true
  end

  context_schema do
    field :topics, icon: "fa-tags", label: "Topics", description: "Main subjects and analysis goals"
    field :code, icon: "fa-code", label: "Code", description: "Key libraries and techniques used"
    field :notes, icon: "fa-sticky-note", label: "Notes", description: "Important findings and results"
  end

  tools do
    # Import shared Jupyter operations tools (always visible - Phase 1)
    import_shared_tools :jupyter_operations, visibility: "always"

    # Import shared Python execution tools (always visible - Phase 1)
    import_shared_tools :python_execution, visibility: "always"

    # Import shared file operations tools (always visible - Phase 1)
    import_shared_tools :file_operations, visibility: "always"

    # Import shared file reading tools (always visible - Phase 1)
    import_shared_tools :file_reading, visibility: "always"

    # COMBINED TOOL FOR xAI GROK - Optimal for parallel function calling
    # This creates the notebook AND adds cells in ONE operation
    define_tool "create_and_populate_jupyter_notebook", "Create a new Jupyter notebook AND add cells in one operation (USE THIS FOR CREATING NEW NOTEBOOKS)" do
      parameter :filename, "string", "Base filename for the notebook", required: true
      parameter :cells, "array", "Array of cell objects to add", required: true, items: { "type" => "object" }
      parameter :run, "boolean", "Whether to run the cells after adding", required: false
    end

    # Grok-Code agent for complex code generation
    define_tool "grok_code_agent", "Call Grok-Code-Fast-1 agent for complex notebook code generation" do
      parameter :task, "string", "Description of the code generation task", required: true
      parameter :notebook_context, "string", "Context about the current notebook state", required: false
      parameter :cell_content, "string", "Existing cell content to modify or reference", required: false
    end

    # Monadic state management tool (read-only - saving is automatic)
    define_tool "monadic_load_state", "Load notebook context from session state. Use this ONLY when you need to reference previous notebook state (e.g., to get the current notebook filename or check if Jupyter is running). Do NOT call this on every turn." do
      parameter :app, "string", "App name (defaults to current app)", required: false
      parameter :key, "string", "State key to load (use 'context' for notebook context)", required: true
      parameter :default, "object", "Default value if state is missing", required: false
      parameter :session, "object", "Session object (automatically provided)", required: false
    end
    # Note: monadic_save_state is called automatically by jupyter tools
    # Do NOT define it as a tool - LLM should not call it directly
  end
end
