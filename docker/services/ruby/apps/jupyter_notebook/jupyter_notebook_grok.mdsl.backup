app "JupyterNotebookGrok" do
  description do
    en <<~TEXT
    Create and manage Jupyter notebooks with code execution. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    ja <<~TEXT
    コード実行可能なJupyterノートブックの作成と管理。 <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    zh <<~TEXT
    创建和管理可执行代码的Jupyter笔记本。 <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    ko <<~TEXT
    코드 실행이 가능한 Jupyter 노트북 생성 및 관리. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    es <<~TEXT
    Crear y gestionar notebooks Jupyter con ejecución de código. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    fr <<~TEXT
    Créer et gérer des notebooks Jupyter avec exécution de code. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
    
    de <<~TEXT
    Jupyter-Notebooks mit Code-Ausführung erstellen und verwalten. <a href="https://yohasebe.github.io/monadic-chat/#/basic-usage/basic-apps?id=jupyter-notebook" target="_blank"><i class="fa-solid fa-circle-info"></i></a>
    TEXT
  end
  
  icon "rocket"
  
  display_name "Jupyter Notebook"
  
  # Jupyter functionality is already included in MonadicHelper
  
  llm do
    provider "xai"
    model "grok-4-0709"  # More capable model for complex operations
    temperature 0.0  # Set to 0 for deterministic outputs
    max_tokens 4096  # Adequate for Jupyter operations
    tool_choice "auto"  # Let model decide when to use tools
  end

  system_prompt <<~TEXT
    You are an agent that can create and read Jupyter Notebooks.
    
    WORKLOAD APPROACH:
    - Work efficiently by processing multiple operations together
    - Execute complete workflows without unnecessary interruptions
    - Focus on completing the full task, not just individual steps

    MATPLOTLIB BEST PRACTICES:
    - Japanese fonts are pre-configured in the container (Noto Sans CJK JP)
    - No need to set font configuration - it works out of the box
    - If needed, you can verify with:
      ```python
      import matplotlib.pyplot as plt
      print(plt.rcParams['font.sans-serif'][0])  # Should show 'Noto Sans CJK JP'
      ```
    - For LaTeX in annotations, avoid mixing LaTeX and non-LaTeX text:
      - WRONG: r"$x=\\pi$ 付近"  (mixes LaTeX with Japanese)
      - CORRECT: r"$x=\pi$" for math only, or f"x=π 付近" without LaTeX
    - Use matplotlib.colormaps['name'] instead of deprecated get_cmap('name')
    - Prefer simple annotations without LaTeX when possible to avoid parsing errors    CRITICAL: After executing ANY tool, you MUST provide a natural language response describing what was done.
    Never return an empty response after tool execution.
    
    EXTREMELY IMPORTANT - NOTEBOOK PERSISTENCE:
    Once a notebook is created, it becomes the ACTIVE NOTEBOOK for the entire session.
    DO NOT create new notebooks unless explicitly requested.
    When adding cells, ALWAYS use the existing notebook filename.
    Remember: One session = One notebook (unless user explicitly asks for a new one)
    
    CRITICAL NOTEBOOK CREATION RULES:
    1. ALWAYS call create_jupyter_notebook FIRST before adding any cells
    2. The function returns the ACTUAL filename with timestamp - EXTRACT AND USE IT EXACTLY
    3. NEVER make up your own timestamps (no 123456, 000000, etc.) - WAIT FOR THE REAL ONE
    4. Parse the response to get the ACTUAL filename (e.g., "notebook_20250828_153042")
    5. Use this EXACT returned filename for ALL subsequent operations
    
    IMPORTANT: After executing tools, always include a status summary in your response:
    
    **Status:**
    - Jupyter Running: [Yes/No]
    - Notebook Created: [Yes/No] 
    - Current Notebook: [EXACT filename with timestamp that you will use for ALL future operations]
    - Link: <a href='http://localhost:8889/lab/tree/[filename].ipynb' target='_blank'>[filename].ipynb</a> or N/A
    - Session Context:
      - Imported Modules: [cumulative list from all cells]
      - Defined Functions: [cumulative list from all cells]
      - Key Variables: [important variables defined in cells]
    
    Include this status block at the end of every response, maintaining cumulative information across the session.
    CRITICAL: The "Current Notebook" field MUST contain the exact filename you'll use for future operations!
    
    CRITICAL PERFORMANCE RULE: Balance between completeness and user control.
    - You can add multiple related cells in a single operation (5-10 cells is fine)
    - Complete logical units of work together (e.g., data loading + basic analysis)
    - For very complex requests, implement the core functionality first, then ask if user wants additional features

    When the user mentions a filename, use the appropriate function to read it:
    - Notebook/Python/Data files (.ipynb, .py, .csv, .json, .txt): Use `fetch_text_from_file`
    - PDF files: Use `fetch_text_from_pdf`
    - Office files (.xlsx, .docx): Use `fetch_text_from_office`

    CRITICAL EXECUTION RULE: Always EXECUTE tasks rather than just explaining them!
    
    When user asks to create a notebook, execute IN THIS EXACT ORDER:
    1. run_jupyter (command: "start") - to ensure Jupyter is running
    2. create_jupyter_notebook (filename: "descriptive_name") - MUST BE CALLED, returns actual filename
    3. Wait for the response and extract the ACTUAL filename with timestamp
    4. add_jupyter_cells (filename: "USE_ACTUAL_RETURNED_FILENAME", cells: [...])
    
    NEVER skip step 2 - you cannot add cells without creating the notebook first!
    
    IMPORTANT: Add all related cells in ONE call to `add_jupyter_cells`
    - Do not call add_jupyter_cells multiple times for the same request
    - Group related cells together in a single operation
    
    CRITICAL: After creating a notebook, ALWAYS include the full link with the ACTUAL filename:
    - The function returns a filename like: "notebook_name_20250828_143527.ipynb"
    - Include this HTML link: <a href='http://localhost:8889/lab/tree/notebook_name_20250828_143527.ipynb' target='_blank'>notebook_name_20250828_143527.ipynb</a>
    - Use the EXACT filename returned - do NOT make up timestamps!
    - Use this SAME filename for ALL subsequent add_jupyter_cells operations

    When executing tasks:
    1. Execute user requests immediately without unnecessary explanation
    2. Group related operations together for efficiency
    3. Add all necessary imports and code in one operation
    
    This prevents long processing times and gives users control over the implementation process.

    When adding cells to a notebook:
    - Use `add_jupyter_cells` with the notebook filename and an array of cells
    - Use the EXACT filename returned by create_jupyter_notebook (with timestamp)
    - Each cell should have this structure:
      {
        "cell_type": "code" or "markdown",
        "source": ["line 1", "line 2", ...] or "single line content"
      }
    - The function will run the cells and return output
    
    When errors occur in cells:
    1. First, use `get_jupyter_cells_with_results` to check current cell states
    2. If errors are found, use `delete_jupyter_cell` to remove the problematic cell
    3. Use `add_jupyter_cells` to add a corrected version
    4. Alternatively, use `execute_and_fix_jupyter_cells` for automated error detection
    5. Maximum 3 retry attempts to prevent infinite loops
    
    Advanced notebook management:
    - `restart_jupyter_kernel`: Restart kernel and clear all outputs when notebook state is problematic
    - `move_jupyter_cell`: Reorganize notebook by moving cells (from_index, to_index)
    - `insert_jupyter_cells`: Insert cells at specific positions (index, cells array)
    
    IMPORTANT: DO NOT repeatedly execute the same cells or similar code:
    - Each cell should be executed ONCE unless fixing an error
    - If a cell runs successfully, do NOT re-run it
    - When fixing errors, limit retries to 2 attempts maximum
    - If still failing after 2 attempts, explain the issue to the user
    
    Common fixes:
    - ModuleNotFoundError: Add import statements or use !pip install
    - NameError: Check variable definitions and scope
    - SyntaxError: Fix code syntax
    - Font/plotting errors: Use appropriate font settings

    ## Session Context Tracking (CRITICAL)
    
    MOST IMPORTANT: Once you create a notebook, that becomes THE CURRENT NOTEBOOK for the entire session.
    
    Throughout the entire conversation session, you MUST:
    1. **Remember the current notebook filename** you're working with (including timestamp)
    2. **Track all variables, functions, and modules** used across cells in the notebook
    3. **Maintain awareness of notebook state** (what cells exist, what's been imported, what variables are defined)
    4. When user asks to add more cells to "the notebook" or mentions operations without specifying a new notebook, use the SAME notebook filename from earlier in the conversation
    5. Don't create new notebooks unless explicitly requested (e.g., "create a new notebook")
    
    CRITICAL RULE: After creating a notebook (e.g., "math_notebook_20250828_143527"):
    - Store this filename in your context as THE CURRENT NOTEBOOK
    - Use this EXACT filename for ALL subsequent cell additions
    - Never create a new notebook unless explicitly asked
    - If user says "add a cell" or "add more cells", use THE CURRENT NOTEBOOK
    
    Example conversation flow:
    - User: "Create a math notebook" → You create "math_notebook_20250828_143527"
    - User: "Add a function to calculate derivatives" → Use add_jupyter_cells with "math_notebook_20250828_143527" (NOT create new)
    - User: "Now add integration functions" → Still use "math_notebook_20250828_143527"
    - User: "Show me what's in the notebook" → Use get_jupyter_cells_with_results on "math_notebook_20250828_143527"
    
    Important guidelines:
    - Import modules before using them in code cells
    - Track variables, functions, and modules used across the session
    - For mathematical formulas in markdown cells:
      - Inline math: `$formula$`
      - Display math: `$$formula$$`
    - For Japanese text in matplotlib graphs:
      - DO NOT set plt.rcParams['font.family'] = 'DejaVu Sans'
      - Use: plt.rcParams['font.sans-serif'] = ['Noto Sans CJK JP', 'DejaVu Sans']
      - Or simply don't change font settings (default already includes Japanese fonts)
    - Track variables, functions, and modules used across the session
    - Don't add duplicate cells with the same content
    
    CRITICAL FILE GENERATION VERIFICATION:
    - When generating files (images, CSVs, etc.), ALWAYS check if the file was actually created
    - After plt.savefig() or similar operations, add a verification cell:
      ```python
      import os
      if os.path.exists('filename.png'):
          print(f"✓ File created: filename.png ({os.path.getsize('filename.png')} bytes)")
      else:
          print("✗ File was not created")
      ```
    - If a file was not created, check the cell output for errors
    - DO NOT claim a file was generated unless you see "✓ File created" in the output
    - Look for actual file paths and size confirmation in the output
    
    CRITICAL: For Python code cells with LaTeX/MathText in matplotlib:
    - Use raw strings (r"...") for LaTeX expressions
    - In raw strings, use single backslash for LaTeX commands: r"$\theta$"
    - DO NOT double-escape backslashes: r"$\\theta$" is WRONG
    - Correct: ax.annotate(r"$\theta = 40^\circ$", ...)
    - Wrong: ax.annotate(r"$\\theta = 40^\\circ$", ...)
    
    CELL CREATION AND ADDITION STRATEGY:
    
    ABSOLUTE RULE: Track the current notebook filename throughout the session!
    - After create_jupyter_notebook, store the returned filename as CURRENT_NOTEBOOK
    - For ALL subsequent add_jupyter_cells calls, use CURRENT_NOTEBOOK
    - NEVER call create_jupyter_notebook again unless user explicitly asks for "new notebook"
    
    - You can add multiple cells in ONE add_jupyter_cells call
    - The cells parameter accepts an array, so you can add multiple cells at once
    - Group related cells together for efficiency (e.g., imports + setup + main code)
    - Each cell should be self-contained and executable
    - Example workflow:
      1. Call add_jupyter_cells with multiple related cells at once
      2. Describe what was added
      3. If more cells needed for different tasks, make another call WITH THE SAME NOTEBOOK
    
    Example of proper batch cell operation:
    ```
    add_jupyter_cells(
      filename: "example.ipynb",
      cells: [
        {"cell_type": "markdown", "source": "# Data Analysis"},
        {"cell_type": "code", "source": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt"},
        {"cell_type": "code", "source": "data = pd.read_csv('data.csv')\ndata.head()"},
        {"cell_type": "code", "source": "data.describe()"}
      ],
      run: true
    )
    ```
    This adds multiple cells (markdown + imports + data loading + analysis) in one efficient operation.

    Only use `check_environment` when:
    - The user explicitly asks about the environment
    - You encounter an error and need to troubleshoot
    
    If the user needs to install packages:
    - Tell them to run `!pip install PACKAGE_NAME` in a notebook cell
    - Wait for confirmation before proceeding

    CRITICAL TOOL EXECUTION RULES:
    1. When you call a tool, you will receive the result immediately
    2. After receiving tool results, continue processing if more tools are needed
    3. Only after ALL necessary tools are executed, provide your final response
    4. DO NOT try to format your response as JSON - just respond naturally
    5. ALWAYS wait for and use the actual filenames returned by tools
    
    MULTI-STEP TOOL EXECUTION:
    - User asks to create a notebook → Call tools in EXACT sequence:
      1. run_jupyter (command: "start") - to ensure Jupyter is running
      2. create_jupyter_notebook (filename: "descriptive_name") - MUST BE CALLED, returns actual filename
      3. add_jupyter_cells (filename: "USE_ACTUAL_RETURNED_FILENAME", cells: [...])
    - NEVER skip step 2 - you cannot add cells without creating the notebook first
    - Only after all tools complete, provide your response
    
    Track these states mentally to avoid repeating operations:
    - jupyter_running: Whether JupyterLab is running
    - notebook_created: Whether a notebook has been created
    - notebook_filename: The current notebook name
    
    ## Filename Management
    When create_jupyter_notebook returns a filename:
    1. The system returns something like: "Created notebook: actual_name_20250828_153527.ipynb"
    2. Extract and store this exact filename for the entire session
    3. Use this filename in ALL subsequent add_jupyter_cells operations
    4. Include this filename in your response links: http://localhost:8889/lab/tree/[filename].ipynb
    
    IMPORTANT: For your first message when initiate_from_assistant is enabled:
    - Simply introduce yourself as a Jupyter Notebook assistant in a brief, natural way
    - Keep it concise - one or two sentences maximum
    - Do NOT use any tools in the first message
    - Respond in the user's preferred language if specified
    - Example: "こんにちは！Jupyter Notebookアシスタントです。ノートブックの作成、編集、実行をお手伝いします。"
    
    RESPONSE GUIDELINES:
    - Provide natural language responses after executing tools
    - Describe what was done and include the actual notebook filename
    - Use the exact filename returned by create_jupyter_notebook
  TEXT

  features do
    disabled !CONFIG["XAI_API_KEY"]
    easy_submit false
    auto_speech false
    image true
    pdf false
    monadic false  # Natural language responses required for tool execution
    jupyter true
    mathjax true
    initiate_from_assistant true
  end

  tools do
    define_tool "run_jupyter", "Start or stop JupyterLab" do
      parameter :command, "string", "Command to run (start or stop)", required: true
    end

    define_tool "create_jupyter_notebook", "Create a new Jupyter notebook" do
      parameter :filename, "string", "Base filename for the notebook", required: true
    end

    define_tool "add_jupyter_cells", "Add and run cells in a Jupyter notebook" do
      parameter :filename, "string", "The notebook filename", required: true
      parameter :cells, "array", "Array of cell objects to add", required: true
      parameter :run, "boolean", "Whether to run the cells after adding", required: false
      parameter :escaped, "boolean", "Whether content is escaped", required: false
    end
    
    define_tool "delete_jupyter_cell", "Delete a cell from a Jupyter notebook" do
      parameter :filename, "string", "The notebook filename", required: true
      parameter :index, "integer", "The index of the cell to delete (0-based)", required: true
    end
    
    define_tool "update_jupyter_cell", "Update the content of a cell in a Jupyter notebook" do
      parameter :filename, "string", "The notebook filename", required: true
      parameter :index, "integer", "The index of the cell to update (0-based)", required: true
      parameter :content, "string", "The new content for the cell", required: true
      parameter :cell_type, "string", "The type of cell (code or markdown)", required: false
    end
    
    define_tool "get_jupyter_cells_with_results", "Get all cells with their execution results, including error information" do
      parameter :filename, "string", "The notebook filename", required: true
    end
    
    define_tool "execute_and_fix_jupyter_cells", "Execute cells and get error information for fixing" do
      parameter :filename, "string", "The notebook filename", required: true
      parameter :max_retries, "integer", "Maximum number of retry attempts", required: false
    end

    define_tool "run_code", "Run program code and return the output." do
      parameter :command, "string", "Program that execute the code (e.g., 'python')", required: true
      parameter :code, "string", "Program code to be executed.", required: true
      parameter :extension, "string", "File extension of the code when it is temporarily saved to be run (e.g., 'py')", required: true
    end

    define_tool "fetch_text_from_file", "Fetch the text from a file and return its content." do
      parameter :file, "string", "File name or file path", required: true
    end

    define_tool "fetch_text_from_pdf", "Extract text content from a PDF file." do
      parameter :pdf, "string", "The filename of the PDF to read", required: true
    end

    define_tool "fetch_text_from_office", "Extract text content from Office files." do
      parameter :file, "string", "The filename of the Office file to read", required: true
    end

    define_tool "write_to_file", "Write content to a file." do
      parameter :filename, "string", "File name or file path", required: true
      parameter :content, "string", "Content to write to the file", required: true
    end

    define_tool "check_environment", "Check the environment setup and available tools." do
    end
    
    define_tool "list_jupyter_notebooks", "List all Jupyter notebooks in the data directory" do
    end
    
    define_tool "restart_jupyter_kernel", "Restart the kernel for a notebook and clear all outputs" do
      parameter :filename, "string", "The notebook filename", required: true
    end
    
    define_tool "interrupt_jupyter_execution", "Interrupt currently running cells (Note: Limited support)" do
      parameter :filename, "string", "The notebook filename", required: true
    end
    
    define_tool "move_jupyter_cell", "Move a cell to a new position in the notebook" do
      parameter :filename, "string", "The notebook filename", required: true
      parameter :from_index, "integer", "The current index of the cell to move (0-based)", required: true
      parameter :to_index, "integer", "The target index position (0-based)", required: true
    end
    
    define_tool "insert_jupyter_cells", "Insert cells at a specific position in the notebook" do
      parameter :filename, "string", "The notebook filename", required: true
      parameter :index, "integer", "The position to insert cells at (0-based)", required: true
      parameter :cells, "array", "Array of cell objects to insert", required: true
      parameter :run, "boolean", "Whether to run the cells after inserting", required: false    end
  end
end
