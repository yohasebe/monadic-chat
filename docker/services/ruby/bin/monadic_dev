#!/usr/bin/env ruby

# frozen_string_literal: false

require "optimist"
require_relative "../lib/monadic/version"

# Change current directory to the parent directory of the directory containing this file
Dir.chdir(File.expand_path(File.join(__dir__, "..")))

DEFAULT_PORT = 4567
PID_FILE = __dir__ + "/falcon.pid"

DATA_DIR = File.expand_path(File.join(ENV["HOME"], "monadic", "data"))
LOG_DIR = File.expand_path(File.join(ENV["HOME"], "monadic", "log"))

Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)
Dir.mkdir(LOG_DIR) unless Dir.exist?(LOG_DIR)

File.open(File.join(LOG_DIR, "command.log"), "w") {}
File.open(File.join(LOG_DIR, "jupyter.log"), "w") {}

# Helper methods for OS detection
def is_mac?
  RUBY_PLATFORM.include?('darwin')
end

def is_linux?
  RUBY_PLATFORM.include?('linux')
end

# Select appropriate Selenium image based on architecture
selenium_image = "selenium/standalone-chrome:latest"
if is_mac?
  if `uname -m`.chomp == "arm64"
    selenium_image = "seleniarm/standalone-chromium:latest"
  end
end

# Set environment variables
ENV["SELENIUM_IMAGE"] = selenium_image
ENV["MONADIC_VERSION"] = Monadic::VERSION.to_s
ENV["HOST_OS"] = `uname -s`.chomp

# Load UI_LANGUAGE from env file if exists
env_file_path = File.expand_path(File.join(ENV["HOME"], "monadic", "config", "env"))
if File.exist?(env_file_path)
  File.readlines(env_file_path).each do |line|
    if line.start_with?("UI_LANGUAGE=")
      ENV["UI_LANGUAGE"] = line.split("=", 2)[1].strip
      break
    end
  end
end

# Define required containers for the application
# Note: Selenium is optional and controlled by SELENIUM_ENABLED in env file
REQUIRED_CONTAINERS = [
  "monadic-chat-python-container",
  "monadic-chat-syntree-container",
  "monadic-chat-ollama-container",
  "monadic-chat-pgvector-container"
]

# Parse command line options
opts = Optimist.options do
  version Monadic::VERSION.to_s
  banner "Usage: monadic [start|stop|restart|export|input] [options]"
  opt :daemonize, "Enable or disable daemon mode", default: false
  opt :log, "Enable or disable logging mode", default: false
  opt :port, "Specify the port number", type: :integer, default: DEFAULT_PORT
end

DOCKER_HOME = File.expand_path(File.join(__dir__, "..", ".."))

# Helper methods for container management
def container_exists?(container_name)
  system("docker container inspect #{container_name} > /dev/null 2>&1")
end

def container_running?(container_name)
  return false unless container_exists?(container_name)
  `docker container inspect #{container_name} --format '{{.State.Status}}'`.chomp == "running"
end

def start_server(opts)
  # Use support scripts to start Docker (same as Electron app)
  # This ensures consistent behavior between Electron app and CLI

  # Use platform-specific Docker startup script
  support_scripts_dir = File.expand_path(File.join(DOCKER_HOME, "support_scripts"))

  case RUBY_PLATFORM
  when /darwin/
    start_docker_script = File.join(support_scripts_dir, "mac-start-docker.sh")
  when /linux/
    # Check if running in WSL2
    if File.exist?("/proc/version") && File.read("/proc/version").include?("microsoft")
      start_docker_script = File.join(support_scripts_dir, "wsl2-start-docker.sh")
    else
      start_docker_script = File.join(support_scripts_dir, "linux-start-docker.sh")
    end
  else
    puts "\nUnsupported platform: #{RUBY_PLATFORM}"
    puts "Please start Docker Desktop manually and try again.\n"
    exit 1
  end

  # Start Docker Desktop if not running (same as Electron app)
  # Don't wait - let monadic.sh handle the waiting
  unless system("docker info > /dev/null 2>&1")
    puts "Docker Desktop is not running. Starting it..."

    case RUBY_PLATFORM
    when /darwin/
      system("open -a Docker")
    when /linux/
      if File.exist?("/proc/version") && File.read("/proc/version").include?("microsoft")
        # WSL2
        system("wsl.exe -d docker-desktop -e sh -c 'exit 0'")
      else
        system("systemctl --user start docker-desktop 2>/dev/null") || system("sudo systemctl start docker")
      end
    end

    puts "Docker Desktop startup initiated. Docker Compose will wait for it to be ready."
  else
    puts "Docker Desktop is already running."
  end

  # Call monadic.sh start (same as Electron app)
  monadic_sh = File.expand_path(File.join(DOCKER_HOME, "..", "monadic.sh"))

  if opts[:daemonize]
    puts "Starting Monadic Chat in daemon mode..."
    system("#{monadic_sh} start > #{File.join(LOG_DIR, 'monadic.log')} 2>&1")
    puts "Monadic Chat started"
    puts "System available at: http://localhost:#{DEFAULT_PORT}"
  else
    puts "Starting Monadic Chat in debug mode..."
    exec("#{monadic_sh} start")
  end
end

def stop_server
  # Stop the main server process (Falcon)
  begin
    # Find and kill falcon processes
    falcon_pids = `pgrep -f "falcon serve"`.strip.split("\n")
    if falcon_pids.any?
      falcon_pids.each do |pid|
        begin
          Process.kill(9, pid.to_i)
          puts "Killed falcon process #{pid}"
        rescue Errno::ESRCH
          # Process already stopped
        end
      end
      puts "Server stopped; Stopping docker containers"
    else
      puts "Server not running"
    end
  rescue StandardError => e
    puts "Error stopping server: #{e.message}"
  end

  # Stop all required containers
  REQUIRED_CONTAINERS.each do |container_name|
    if container_exists?(container_name)
      system("docker container stop #{container_name}")

      # Wait for container to stop
      30.times do  # Try for 15 seconds (30 * 0.5)
        break unless container_running?(container_name)
        sleep 0.5
      end
    end
  end
end

# Restart the server
def restart_server(opts)
  stop_server
  sleep 2  # Wait for processes to fully stop
  start_server(opts)
end

def print_status
  # Check main server status (Falcon)
  falcon_pids = `pgrep -f "falcon serve"`.strip.split("\n")
  server_status = falcon_pids.any? ? "running (PIDs: #{falcon_pids.join(', ')})" : "not running"
  puts "Main server is #{server_status}"

  # Print status of required containers
  puts "\nContainer Status:"
  REQUIRED_CONTAINERS.each do |container_name|
    if container_exists?(container_name)
      status = container_running?(container_name) ? "running" : "stopped"
      puts "#{container_name}: #{status}"
    else
      puts "#{container_name}: does not exist"
    end
  end
end

def export_document_db
  command = <<~SHELL
    pg_dump monadic | gzip > "#{DATA_DIR}/monadic.gz"
  SHELL

  if system(command)
    puts "Document DB exported to 'monadic.gz'"
  else
    puts "Failed to export document DB"
  end
end

def import_document_db
  command = <<~SHELL
    dropdb monadic && createdb --locale=C --template=template0 monadic && gunzip -c "#{DATA_DIR}/monadic.gz" | psql monadic
  SHELL

  if system(command)
    puts "Document DB imported from 'monadic.gz'"
  else
    puts "Failed to import document DB"
  end
end

# Parse and execute subcommand
subcommand = ARGV.shift

case subcommand
when "start"
  start_server(opts)
when "stop"
  stop_server
when "restart"
  restart_server(opts)
when "export"
  export_document_db
when "import"
  import_document_db
when "status"
  print_status
else
  Optimist.die "Unknown subcommand. Use \"start\", \"stop\", \"restart\", \"export\", \"import\", or \"status\""
end
