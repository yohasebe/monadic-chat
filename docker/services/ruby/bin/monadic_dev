#!/usr/bin/env ruby

# frozen_string_literal: false

require "optimist"
require "open3"
require_relative "../lib/monadic/version"

# Change current directory to the parent directory of the directory containing this file
Dir.chdir(File.expand_path(File.join(__dir__, "..")))

DEFAULT_PORT = 4567
PID_FILE = __dir__ + "/falcon.pid"

DATA_DIR = File.expand_path(File.join(ENV["HOME"], "monadic", "data"))
LOG_DIR = File.expand_path(File.join(ENV["HOME"], "monadic", "log"))

# Find docker command (system() doesn't use login shell PATH)
DOCKER_CMD = `which docker 2>/dev/null`.strip
DOCKER_CMD = "/usr/local/bin/docker" if DOCKER_CMD.empty?

# Verify docker command exists
unless File.executable?(DOCKER_CMD)
  STDERR.puts "ERROR: Docker command not found at: #{DOCKER_CMD}"
  STDERR.puts "Please ensure Docker is installed and in PATH"
  exit 1
end

STDERR.puts "[DEBUG] Using docker command: #{DOCKER_CMD}" if ENV['EXTRA_LOGGING']
STDERR.puts "[DEBUG] DOCKER_CONTEXT: #{ENV['DOCKER_CONTEXT']}" if ENV['EXTRA_LOGGING']

Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)
Dir.mkdir(LOG_DIR) unless Dir.exist?(LOG_DIR)

File.open(File.join(LOG_DIR, "command.log"), "w") {}
File.open(File.join(LOG_DIR, "jupyter.log"), "w") {}

# Helper methods for OS detection
def is_mac?
  RUBY_PLATFORM.include?('darwin')
end

def is_linux?
  RUBY_PLATFORM.include?('linux')
end

# Select appropriate Selenium image based on architecture
selenium_image = "selenium/standalone-chrome:latest"
if is_mac?
  if `uname -m`.chomp == "arm64"
    selenium_image = "seleniarm/standalone-chromium:latest"
  end
end

# Set environment variables
ENV["SELENIUM_IMAGE"] = selenium_image
ENV["MONADIC_VERSION"] = Monadic::VERSION.to_s
ENV["HOST_OS"] = `uname -s`.chomp

# Load UI_LANGUAGE from env file if exists
env_file_path = File.expand_path(File.join(ENV["HOME"], "monadic", "config", "env"))
if File.exist?(env_file_path)
  File.readlines(env_file_path).each do |line|
    if line.start_with?("UI_LANGUAGE=")
      ENV["UI_LANGUAGE"] = line.split("=", 2)[1].strip
      break
    end
  end
end

# Define required containers for the application
# Note: Selenium is optional and controlled by SELENIUM_ENABLED in env file
REQUIRED_CONTAINERS = [
  "monadic-chat-python-container",
  "monadic-chat-syntree-container",
  "monadic-chat-ollama-container",
  "monadic-chat-pgvector-container"
]

# Parse command line options
opts = Optimist.options do
  version Monadic::VERSION.to_s
  banner "Usage: monadic [start|stop|restart|export|input] [options]"
  opt :daemonize, "Enable or disable daemon mode", default: false
  opt :log, "Enable or disable logging mode", default: false
  opt :port, "Specify the port number", type: :integer, default: DEFAULT_PORT
end

DOCKER_HOME = File.expand_path(File.join(__dir__, "..", ".."))

# Docker checks (prefer existing sockets; avoid probing non-existent sockets that can crash Desktop)
def probe_docker(context:, host:)
  env = {}
  env['DOCKER_CONTEXT'] = context if context
  env.delete('DOCKER_CONTEXT') unless context
  env['DOCKER_HOST'] = host if host
  env.delete('DOCKER_HOST') unless host
  output, status = Open3.capture2e(env, "#{DOCKER_CMD} info")
  [status.success?, output]
end

def preferred_docker_host
  return ENV['DOCKER_HOST'] if ENV['DOCKER_HOST'] && !ENV['DOCKER_HOST'].empty?

  cli_sock = File.expand_path("~/Library/Containers/com.docker.docker/Data/docker-cli.sock")
  return "unix://#{cli_sock}" if File.exist?(cli_sock) || File.socket?(cli_sock)

  run_sock = File.expand_path("~/.docker/run/docker.sock")
  return "unix://#{run_sock}" if File.exist?(run_sock) || File.socket?(run_sock)

  colima_sock = File.expand_path("~/.colima/default/docker.sock")
  return "unix://#{colima_sock}" if File.exist?(colima_sock) || File.socket?(colima_sock)

  default_sock = "/var/run/docker.sock"
  return "unix://#{default_sock}" if File.exist?(default_sock) || File.socket?(default_sock)

  nil
end

def wait_for_socket(host, seconds = 90)
  return true unless host && host.start_with?("unix://")
  socket_path = host.sub("unix://", "")
  seconds.times do
    return true if File.socket?(socket_path)
    sleep 1
  end
  File.socket?(socket_path)
end

def ensure_docker_ready
  desktop_sock = File.expand_path("~/Library/Containers/com.docker.docker/Data/docker-cli.sock")

  # On macOS, only attempt to start Desktop if the Desktop socket is missing
  if is_mac?
    script = File.expand_path(File.join(DOCKER_HOME, "services", "support_scripts", "mac-start-docker.sh"))
    if File.executable?(script) && !File.socket?(desktop_sock)
      ok = system(script)
      return [false, "Docker Desktop not ready"] unless ok
    end
  end

  host = preferred_docker_host
  # If still no host detected, fall back to Desktop socket to check once
  host ||= "unix://#{desktop_sock}"

  # Wait up to 90s for the socket to exist (no repeated docker info calls)
  if host.start_with?("unix://")
    socket_path = host.sub("unix://", "")
    90.times do
      break if File.socket?(socket_path)
      sleep 1
    end
    return [false, "Docker socket #{socket_path} not available"] unless File.socket?(socket_path)
  end

  ctx = ENV['DOCKER_CONTEXT']
  ok, output = probe_docker(context: ctx, host: host)

  if ok
    ctx ? ENV['DOCKER_CONTEXT'] = ctx : ENV.delete('DOCKER_CONTEXT')
    host ? ENV['DOCKER_HOST'] = host : ENV.delete('DOCKER_HOST')
    return [true, output]
  end

  [false, output]
end

def try_start_docker
  return false unless is_mac?
  script = File.expand_path(File.join(DOCKER_HOME, "services", "support_scripts", "mac-start-docker.sh"))
  return false unless File.executable?(script)
  STDERR.puts "[DEBUG] Attempting to start Docker Desktop via #{script}" if ENV['EXTRA_LOGGING']
  system(script)
end

# Helper methods for container management
def container_exists?(container_name)
  system("#{DOCKER_CMD} container inspect #{container_name} > /dev/null 2>&1")
end

def container_running?(container_name)
  return false unless container_exists?(container_name)
  `#{DOCKER_CMD} container inspect #{container_name} --format '{{.State.Status}}'`.chomp == "running"
end

def start_server(opts)
  # Check if Docker daemon is running (not just the app), with context fallback and auto-start
  docker_ok = false
  docker_output = ""
  started = false
  desktop_sock = File.expand_path("~/Library/Containers/com.docker.docker/Data/docker-cli.sock")
  # Default DOCKER_HOST to Desktop socket on mac if not set and socket exists
  if is_mac? && !ENV['DOCKER_HOST'] && File.socket?(desktop_sock)
    ENV['DOCKER_HOST'] = "unix://#{desktop_sock}"
    STDERR.puts "[DEBUG] Setting DOCKER_HOST to Desktop socket #{ENV['DOCKER_HOST']}" if ENV['EXTRA_LOGGING']
  end

  if ENV["SKIP_DOCKER_CHECK"]
    puts "⏭️  Skipping Docker daemon check (SKIP_DOCKER_CHECK is set)"
    host = preferred_docker_host || "unix://#{desktop_sock}"
    unless wait_for_socket(host)
      puts "⚠️  Docker socket not available yet (host=#{host || 'default'})"
      exit 1
    end
    docker_ok = true
  else
    60.times do
      docker_ok, docker_output = ensure_docker_ready
      break if docker_ok

      unless started
        started = try_start_docker
      end

      sleep 1
    end
  end

  unless docker_ok
    STDERR.puts "[DEBUG] Docker info full output:\n#{docker_output}" if ENV['EXTRA_LOGGING']
    puts "\n" + "=" * 70
    puts "⚠️  Docker daemon is not responding"
    puts "=" * 70
    puts "\nDocker Desktop appears to be running but the daemon hasn't started."
    puts "\nTO FIX THIS ISSUE:"
    puts "  1. Quit Docker Desktop completely:"
    puts "     - Click Docker whale icon in menu bar → Quit Docker Desktop"
    puts "     - Or run: killall 'Docker Desktop'"
    puts "  2. Wait 5 seconds"
    puts "  3. Start Docker Desktop from Applications"
    puts "  4. Wait for full initialization (whale icon stops animating)"
    puts "  5. Run: rake server:debug\n"
    puts "\nALTERNATIVE: Use 'electron .' which manages Docker automatically.\n"
    puts "=" * 70 + "\n"
    exit 1
  else
    puts "✅ Docker daemon is responding"
  end

  # Stop Ruby container if it's running (development server runs locally)
  if container_running?("monadic-chat-ruby-container")
    puts "Stopping Ruby container (will run locally instead)..."
    system("#{DOCKER_CMD} container stop monadic-chat-ruby-container > /dev/null 2>&1")
  end

  # Start required support containers (NOT Ruby container)
  REQUIRED_CONTAINERS.each do |container_name|
    next unless container_exists?(container_name)
    unless container_running?(container_name)
      puts "Starting #{container_name}..."
      system("#{DOCKER_CMD} container start #{container_name}")
      # Wait for container to start
      30.times do  # Try for 15 seconds (30 * 0.5)
        break if container_running?(container_name)
        sleep 0.5
      end
    end
  end

  # Check if server is already running locally
  if File.exist?(PID_FILE)
    begin
      pid = File.read(PID_FILE).to_i
      if pid > 0
        Process.kill(0, pid)
        puts "Server is already running"
        return
      end
    rescue Errno::ESRCH, Errno::EPERM
      # Remove PID file if process doesn't exist or we don't have permission
      File.delete(PID_FILE)
    end
  end

  # macOS fork safety for Falcon
  ENV["OBJC_DISABLE_INITIALIZE_FORK_SAFETY"] = "YES"

  # Start local Falcon server
  cmd = "bundle exec falcon serve -b http://0.0.0.0:#{opts[:port] || DEFAULT_PORT} -c config.ru --count 1"

  if opts[:daemonize]
    # Daemon mode: run in background
    puts "Starting Monadic Chat in daemon mode..."
    pid = spawn(cmd, out: File.join(LOG_DIR, "server.log"), err: File.join(LOG_DIR, "server.log"))
    Process.detach(pid)
    File.write(PID_FILE, pid.to_s)
    puts "Server started on port #{opts[:port] || DEFAULT_PORT}"
    puts "System available at: http://localhost:#{opts[:port] || DEFAULT_PORT}"
  else
    # Debug mode: run in foreground with output
    puts "Starting Monadic Chat in debug mode..."
    puts "Access the application at: http://localhost:#{opts[:port] || DEFAULT_PORT}"
    puts "Press Ctrl+C to stop\n\n"
    exec(cmd)
  end
end

def stop_server
  # Stop the main server process (Falcon)
  begin
    # Find and kill falcon processes
    falcon_pids = `pgrep -f "falcon serve"`.strip.split("\n")
    if falcon_pids.any?
      falcon_pids.each do |pid|
        begin
          Process.kill(9, pid.to_i)
          puts "Killed falcon process #{pid}"
        rescue Errno::ESRCH
          # Process already stopped
        end
      end
      puts "Server stopped; Stopping docker containers"
    else
      puts "Server not running"
    end
  rescue StandardError => e
    puts "Error stopping server: #{e.message}"
  end

  # Stop all required containers
  REQUIRED_CONTAINERS.each do |container_name|
    if container_exists?(container_name)
      system("#{DOCKER_CMD} container stop #{container_name}")

      # Wait for container to stop
      30.times do  # Try for 15 seconds (30 * 0.5)
        break unless container_running?(container_name)
        sleep 0.5
      end
    end
  end
end

# Restart the server
def restart_server(opts)
  stop_server
  sleep 2  # Wait for processes to fully stop
  start_server(opts)
end

def print_status
  # Check main server status (Falcon)
  falcon_pids = `pgrep -f "falcon serve"`.strip.split("\n")
  server_status = falcon_pids.any? ? "running (PIDs: #{falcon_pids.join(', ')})" : "not running"
  puts "Main server is #{server_status}"

  # Print status of required containers
  puts "\nContainer Status:"
  REQUIRED_CONTAINERS.each do |container_name|
    if container_exists?(container_name)
      status = container_running?(container_name) ? "running" : "stopped"
      puts "#{container_name}: #{status}"
    else
      puts "#{container_name}: does not exist"
    end
  end
end

def export_document_db
  command = <<~SHELL
    pg_dump monadic | gzip > "#{DATA_DIR}/monadic.gz"
  SHELL

  if system(command)
    puts "Document DB exported to 'monadic.gz'"
  else
    puts "Failed to export document DB"
  end
end

def import_document_db
  command = <<~SHELL
    dropdb monadic && createdb --locale=C --template=template0 monadic && gunzip -c "#{DATA_DIR}/monadic.gz" | psql monadic
  SHELL

  if system(command)
    puts "Document DB imported from 'monadic.gz'"
  else
    puts "Failed to import document DB"
  end
end

# Parse and execute subcommand
subcommand = ARGV.shift

case subcommand
when "start"
  start_server(opts)
when "stop"
  stop_server
when "restart"
  restart_server(opts)
when "export"
  export_document_db
when "import"
  import_document_db
when "status"
  print_status
else
  Optimist.die "Unknown subcommand. Use \"start\", \"stop\", \"restart\", \"export\", \"import\", or \"status\""
end
