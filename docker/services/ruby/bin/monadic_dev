#!/usr/bin/env ruby

# frozen_string_literal: false

require "optimist"
require_relative "../lib/monadic/version"

# Change current directory to the parent directory of the directory containing this file
Dir.chdir(File.expand_path(File.join(__dir__, "..")))

DEFAULT_PORT = 4567
PID_FILE = __dir__ + "/falcon.pid"

DATA_DIR = File.expand_path(File.join(ENV["HOME"], "monadic", "data"))
LOG_DIR = File.expand_path(File.join(ENV["HOME"], "monadic", "log"))

Dir.mkdir(DATA_DIR) unless Dir.exist?(DATA_DIR)
Dir.mkdir(LOG_DIR) unless Dir.exist?(LOG_DIR)

File.open(File.join(LOG_DIR, "command.log"), "w") {}
File.open(File.join(LOG_DIR, "jupyter.log"), "w") {}

# Helper methods for OS detection
def is_mac?
  RUBY_PLATFORM.include?('darwin')
end

def is_linux?
  RUBY_PLATFORM.include?('linux')
end

# Select appropriate Selenium image based on architecture
selenium_image = "selenium/standalone-chrome:latest"
if is_mac?
  if `uname -m`.chomp == "arm64"
    selenium_image = "seleniarm/standalone-chromium:latest"
  end
end

# Set environment variables
ENV["SELENIUM_IMAGE"] = selenium_image
ENV["MONADIC_VERSION"] = Monadic::VERSION.to_s
ENV["HOST_OS"] = `uname -s`.chomp

# Load UI_LANGUAGE from env file if exists
env_file_path = File.expand_path(File.join(ENV["HOME"], "monadic", "config", "env"))
if File.exist?(env_file_path)
  File.readlines(env_file_path).each do |line|
    if line.start_with?("UI_LANGUAGE=")
      ENV["UI_LANGUAGE"] = line.split("=", 2)[1].strip
      break
    end
  end
end

# Define required containers for the application
# Note: Selenium is optional and controlled by SELENIUM_ENABLED in env file
REQUIRED_CONTAINERS = [
  "monadic-chat-python-container",
  "monadic-chat-syntree-container",
  "monadic-chat-ollama-container",
  "monadic-chat-pgvector-container"
]

# Parse command line options
opts = Optimist.options do
  version Monadic::VERSION.to_s
  banner "Usage: monadic [start|stop|restart|export|input] [options]"
  opt :daemonize, "Enable or disable daemon mode", default: false
  opt :log, "Enable or disable logging mode", default: false
  opt :port, "Specify the port number", type: :integer, default: DEFAULT_PORT
end

DOCKER_HOME = File.expand_path(File.join(__dir__, "..", ".."))

# Helper methods for container management
def container_exists?(container_name)
  system("docker container inspect #{container_name} > /dev/null 2>&1")
end

def container_running?(container_name)
  return false unless container_exists?(container_name)
  `docker container inspect #{container_name} --format '{{.State.Status}}'`.chomp == "running"
end

def start_server(opts)
  # Check if Docker is running
  unless system("docker info > /dev/null 2>&1")
    puts "\n" + "="*80
    puts "⚠️  Docker Desktop is not running"
    puts "="*80
    puts "\nPlease start Docker Desktop before running this command."
    puts "You can use 'electron .' to start the Electron app which will"
    puts "automatically start Docker Desktop, or start it manually.\n"
    exit 1
  end

  # Stop existing Ruby container if running
  system("docker container stop monadic-chat-ruby-container > /dev/null") if system("docker container ls | grep monadic-chat-ruby-container > /dev/null")

  # Start required containers
  REQUIRED_CONTAINERS.each do |container_name|
    next unless container_exists?(container_name)
    unless container_running?(container_name)
      system("docker container start #{container_name}")
      # Wait for container to start
      30.times do  # Try for 15 seconds (30 * 0.5)
        break if container_running?(container_name)
        sleep 0.5
      end
    end
  end

  # Check if server is already running
  if File.exist?(PID_FILE)
    begin
      pid = File.read(PID_FILE).to_i
      if pid > 0
        Process.kill(0, pid)
        puts "Server is already running"
        return
      end
    rescue Errno::ESRCH, Errno::EPERM
      # Remove PID file if process doesn't exist or we don't have permission
      File.delete(PID_FILE)
    end
  end

  # Start the server with Falcon
  port_num = opts[:port] || DEFAULT_PORT
  cmd = "falcon serve -b http://0.0.0.0:#{port_num} -c #{DOCKER_HOME}/ruby/config.ru"

  if opts[:daemonize]
    # For daemonized mode, use background process with output redirection
    log_file = File.join(LOG_DIR, "server.log")
    cmd += " >> #{log_file} 2>&1 &"
    puts "Starting server in daemon mode on port #{port_num}..."
    system(cmd)
    sleep 1  # Give server time to start
    puts "Server started on port #{port_num}"
    puts "System available at: http://localhost:#{port_num}"
  else
    # Debug mode - run in foreground
    puts "Starting server in debug mode on port #{port_num}..."
    puts "System available at: http://localhost:#{port_num}"
    exec(cmd)
  end
end

def stop_server
  # Stop the main server process (Falcon)
  begin
    # Find and kill falcon processes
    falcon_pids = `pgrep -f "falcon serve"`.strip.split("\n")
    if falcon_pids.any?
      falcon_pids.each do |pid|
        begin
          Process.kill(9, pid.to_i)
          puts "Killed falcon process #{pid}"
        rescue Errno::ESRCH
          # Process already stopped
        end
      end
      puts "Server stopped; Stopping docker containers"
    else
      puts "Server not running"
    end
  rescue StandardError => e
    puts "Error stopping server: #{e.message}"
  end

  # Stop all required containers
  REQUIRED_CONTAINERS.each do |container_name|
    if container_exists?(container_name)
      system("docker container stop #{container_name}")

      # Wait for container to stop
      30.times do  # Try for 15 seconds (30 * 0.5)
        break unless container_running?(container_name)
        sleep 0.5
      end
    end
  end
end

# Restart the server
def restart_server(opts)
  stop_server
  sleep 2  # Wait for processes to fully stop
  start_server(opts)
end

def print_status
  # Check main server status (Falcon)
  falcon_pids = `pgrep -f "falcon serve"`.strip.split("\n")
  server_status = falcon_pids.any? ? "running (PIDs: #{falcon_pids.join(', ')})" : "not running"
  puts "Main server is #{server_status}"

  # Print status of required containers
  puts "\nContainer Status:"
  REQUIRED_CONTAINERS.each do |container_name|
    if container_exists?(container_name)
      status = container_running?(container_name) ? "running" : "stopped"
      puts "#{container_name}: #{status}"
    else
      puts "#{container_name}: does not exist"
    end
  end
end

def export_document_db
  command = <<~SHELL
    pg_dump monadic | gzip > "#{DATA_DIR}/monadic.gz"
  SHELL

  if system(command)
    puts "Document DB exported to 'monadic.gz'"
  else
    puts "Failed to export document DB"
  end
end

def import_document_db
  command = <<~SHELL
    dropdb monadic && createdb --locale=C --template=template0 monadic && gunzip -c "#{DATA_DIR}/monadic.gz" | psql monadic
  SHELL

  if system(command)
    puts "Document DB imported from 'monadic.gz'"
  else
    puts "Failed to import document DB"
  end
end

# Parse and execute subcommand
subcommand = ARGV.shift

case subcommand
when "start"
  start_server(opts)
when "stop"
  stop_server
when "restart"
  restart_server(opts)
when "export"
  export_document_db
when "import"
  import_document_db
when "status"
  print_status
else
  Optimist.die "Unknown subcommand. Use \"start\", \"stop\", \"restart\", \"export\", \"import\", or \"status\""
end
