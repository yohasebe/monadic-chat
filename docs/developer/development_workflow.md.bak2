# Development Workflow

This document contains guidelines and instructions for developers contributing to the Monadic Chat project.

?> This document is for developers of Monadic Chat itself, not for developers of Monadic Chat applications.

## Testing

### Test Frameworks
- **JavaScript**: Uses Jest for frontend code testing
- **Ruby**: Uses RSpec for backend code testing

### Test Structure
- JavaScript tests are in `test/frontend/`
- Ruby tests are in `docker/services/ruby/spec/`
- App-specific diagnostic scripts are in `docker/services/ruby/scripts/diagnostics/apps/{app_name}/`
- Jest configuration in `jest.config.js`
- Global test setup for JavaScript in `test/setup.js`

### App-Specific Test Scripts
For applications that require specific testing or diagnosis:
- Place test scripts in the diagnostics directory: `docker/services/ruby/scripts/diagnostics/apps/{app_name}/`
- Use descriptive names: `test_feature_name.sh` or `diagnose_issue.rb`
- Avoid placing app-specific test scripts in the project root directory
- Example: Concept Visualizer test scripts are in `docker/services/ruby/scripts/diagnostics/apps/concept_visualizer/`

?> **Important**: Test scripts should NOT be placed in `apps/{app_name}/test/` directories, as files in `test/` subdirectories within apps are ignored during app loading to prevent test scripts from being loaded as applications.

### Running Tests

**Note**: When using `rake server:debug` for development, Ruby tests run directly on the host using your local Ruby environment.

#### Ruby Tests
```bash
rake spec
```

#### JavaScript Tests
```bash
rake jstest        # Run passing JavaScript tests
npm test           # Same as above
rake jstest_all    # Run all JavaScript tests
npm run test:watch # Run tests in watch mode
npm run test:coverage # Run tests with coverage report
```

#### All Tests
```bash
rake test  # Run both Ruby and JavaScript tests
```

## MDSL Development Tools

### MDSL Auto-Completion System (Experimental)

**⚠️ Note: This is an experimental feature and may change or be removed in future versions.**

The MDSL auto-completion system aims to solve a development challenge: keeping tool definitions synchronized between Ruby implementations and MDSL declarations.

#### The Problem It Solves

In Monadic Chat apps, you need to:
1. Implement tool methods in Ruby (`*_tools.rb` files)
2. Declare those tools in MDSL (`*.mdsl` files) so the LLM knows about them

Without auto-completion, you must manually duplicate every method signature, which is:
- Time-consuming and error-prone
- Difficult to maintain when parameters change
- Easy to forget, leaving tools unavailable to the LLM

#### How It Works

When enabled, the system automatically:
1. **Detects** Ruby methods in `*_tools.rb` files
2. **Analyzes** method signatures and infers parameter types
3. **Generates** corresponding MDSL tool definitions
4. **Updates** the MDSL file with missing definitions

#### Example

You write this Ruby method:
```ruby
# novel_writer_tools.rb
def count_num_of_words(text: "")
  text.split.size
end
```

The system automatically generates this MDSL definition:
```ruby
# novel_writer_openai.mdsl
define_tool "count_num_of_words", "Count the num of words" do
  parameter :text, "string", "The text content to process"
end
```

#### Controlling Auto-Completion

```bash
# Disable (default) - Tools work at runtime but MDSL files aren't modified
export MDSL_AUTO_COMPLETE=false

# Enable - Automatically updates MDSL files with missing tool definitions
export MDSL_AUTO_COMPLETE=true

# Debug mode - Same as enabled but with detailed logging
export MDSL_AUTO_COMPLETE=debug
```

#### Important Notes

- **Experimental Feature**: This feature is still under development and may have unexpected behavior
- **Default is OFF**: You must explicitly enable it to modify MDSL files
- **Runtime vs Build Time**: Even when disabled, tools are still available at runtime
- **Backup Files**: Creates backups before modifying MDSL files
- **Standard Tools**: Automatically excludes tools inherited from MonadicApp
- **Smart Detection**: Only processes public methods with tool-like signatures

#### Known Limitations

- May not correctly infer complex parameter types
- Could potentially overwrite manual customizations
- Performance impact on app loading when enabled
- Not recommended for production use

#### Environment Variables

The tool respects the unified debug system:
- `MONADIC_DEBUG=mdsl`: Enable MDSL debug output
- `MONADIC_DEBUG_LEVEL=debug`: Set debug verbosity level

Other debug variables:
- `MDSL_AUTO_COMPLETE=debug`: Enable MDSL debug output
- `APP_DEBUG=1`: Enable general debug output

## Debug System

Monadic Chat uses a unified debug system controlled via environment variables:

### Debug Categories
- `all`: All debug messages
- `app`: General application debugging
- `embeddings`: Text embeddings operations
- `mdsl`: MDSL tool completion
- `tts`: Text-to-Speech operations
- `drawio`: DrawIO grapher operations
- `ai_user`: AI user agent
- `web_search`: Web search operations (includes Tavily)
- `api`: API requests and responses

### Debug Levels
- `none`: No debug output (default)
- `error`: Only errors
- `warning`: Errors and warnings
- `info`: General information
- `debug`: Detailed debug information
- `verbose`: Everything including raw data

### Usage Examples
```bash
# Enable web search debug output
export MONADIC_DEBUG=web_search
export MONADIC_DEBUG_LEVEL=debug

# Enable multiple categories
export MONADIC_DEBUG=api,web_search,mdsl

# Enable all debug output
export MONADIC_DEBUG=all
export MONADIC_DEBUG_LEVEL=verbose

# API debugging (equivalent to Electron's "Extra Logging")
export MONADIC_DEBUG=api
```

### Error Handling Improvements
- **Error Pattern Detection**: System automatically detects repeated errors and stops after 3 similar occurrences
- **UTF-8 Encoding**: All responses are properly handled with fallback encoding replacement
- **Infinite Loop Prevention**: Tool calls are limited to prevent "Maximum function call depth exceeded" errors
- **Graceful Degradation**: Missing API keys result in clear error messages, not crashes

### Usage Examples
```bash
# Enable web search debug output
export MONADIC_DEBUG=web_search
export MONADIC_DEBUG_LEVEL=debug

# Enable multiple categories
export MONADIC_DEBUG=api,web_search,mdsl

# Enable all debug output
export MONADIC_DEBUG=all
export MONADIC_DEBUG_LEVEL=verbose

# API debugging (equivalent to Electron's "Extra Logging")
export MONADIC_DEBUG=api
```

### MDSL Development Best Practices

#### File Structure
Monadic Chat applications now use the MDSL (Monadic Domain Specific Language) format exclusively:

- **App Definition**: `app_name_provider.mdsl` (e.g., `chat_openai.mdsl`)
- **Tool Implementation**: `app_name_tools.rb` (e.g., `chat_tools.rb`)
- **Shared Constants**: `app_name_constants.rb` (optional)

#### Tool Implementation Pattern

When developing MDSL applications, always implement the facade pattern for custom tools:

```ruby
# app_name_tools.rb
class AppNameProvider < MonadicApp
  def custom_method(param:, options: {})
    # 1. Input validation
    raise ArgumentError, "Parameter required" if param.nil?
    
    # 2. Call underlying implementation
    result = perform_operation(param, options)
    
    # 3. Return structured response
    { success: true, data: result }
  rescue StandardError => e
    { success: false, error: e.message }
  end
end
```

#### Empty Tools Block Issue

**Important**: Empty `tools do` blocks in MDSL files can cause "Maximum function call depth exceeded" errors. Always either:

1. **Define tools explicitly** in the MDSL file:
```ruby
tools do
  define_tool "fetch_text_from_pdf", "Extract text from PDF" do
    parameter :pdf, "string", "PDF filename", required: true
  end
end
```

2. **Create a companion tools file** that inherits standard tools:
```ruby
# app_name_tools.rb
class AppNameProvider < MonadicApp
  # Inherits standard tools from MonadicApp
end
```

#### Common Development Issues

**Missing Method Errors:**
- Symptom: `undefined method 'method_name' for an instance of AppName`
- Solution: Create facade methods in `*_tools.rb` file with proper validation

**Maximum function call depth exceeded:**
- Symptom: Error when running app with empty `tools do` block
- Solution: Add explicit tool definitions or create `*_tools.rb` file

**Auto-completion Debugging:**
```bash
# Enable auto-completion with debug output
export MDSL_AUTO_COMPLETE=debug

# Then start the server and load your app
rake server:start

# Check the console output for auto-completion messages
```

**Manual Tool Verification:**
```bash
# Check if tools are properly implemented in Ruby
grep -n "def " apps/your_app/your_app_tools.rb

# Verify tool definitions in MDSL
grep -A5 "tools do" apps/your_app/your_app_provider.mdsl
```

#### Provider-Specific Considerations

- **Function Limits**: OpenAI/Gemini support up to 20 function calls, Claude supports up to 16
- **Code Execution**: All providers use `run_code` for code execution
- **Array Parameters**: OpenAI requires `items` property for array parameters
## MDSL Auto-Completion Control

The MDSL auto-completion system can be controlled using environment variables:

```bash
# Disable auto-completion (useful when debugging MDSL files)
export MDSL_AUTO_COMPLETE=false

# Enable with detailed debug logging
export MDSL_AUTO_COMPLETE=debug

# Enable normally
export MDSL_AUTO_COMPLETE=true

# Default behavior (auto-completion disabled)
# MDSL_AUTO_COMPLETE is unset or false by default
```

## Important: Managing Setup Scripts

The `pysetup.sh` and `rbsetup.sh` files in the repository are placeholder scripts that get replaced during container build with user-provided versions from `~/monadic/config/`. Always commit the original placeholder versions to Git. Before committing changes, reset these files using one of the methods below:

Note: The `olsetup.sh` script is only created by users in `~/monadic/config/` for Ollama model installation and has no placeholder version in the repository.

#### Method 1: Using the Reset Script

Run the provided reset script:

```bash
./docker/services/reset_setup_scripts.sh
```

This will restore the original versions of the setup scripts from git.

#### Method 2: Manual Reset

Alternatively, you can manually reset the files using git:

```bash
git checkout -- docker/services/python/pysetup.sh docker/services/ruby/rbsetup.sh
```

### Git Pre-commit Hook (Optional)

You can set up a git pre-commit hook to automatically reset these files before each commit:

1. Create a file named `pre-commit` in your `.git/hooks/` directory:

```bash
touch .git/hooks/pre-commit
chmod +x .git/hooks/pre-commit
```

2. Add the following content to the pre-commit hook:

```bash
#!/bin/bash
# .git/hooks/pre-commit - Automatically reset setup scripts before commit

# Get the files that are staged for commit
STAGED_FILES=$(git diff --cached --name-only)

# Check if our setup scripts are modified
if echo "$STAGED_FILES" | grep -q "docker/services/python/pysetup.sh\|docker/services/ruby/rbsetup.sh"; then
  echo "⚠️ Setup script changes detected in commit."
  echo "⚠️ Resetting to original versions from git..."
  
  # Reset them
  git checkout -- docker/services/python/pysetup.sh
  git checkout -- docker/services/ruby/rbsetup.sh
  
  # Re-add them to staging
  git add docker/services/python/pysetup.sh
  git add docker/services/ruby/rbsetup.sh
  
  echo "✅ Setup scripts reset. Proceeding with commit."
fi

# Allow the commit to proceed
exit 0
```

This pre-commit hook will automatically detect and reset any changes to the setup scripts before committing.

## Development Environment Setup

### Running Monadic Chat for Development

For development purposes, you can run Monadic Chat without the Electron app:

```bash
rake server:debug
```

This command:
- Starts the server in debug mode with `EXTRA_LOGGING=true`
- Does NOT start the Ruby container - uses host Ruby runtime instead
- Starts all other containers (Python, PostgreSQL, pgvector, Ollama if available)
- Uses files from `/docker/services/ruby/` directly on the host
- Makes the web UI accessible via browser at `http://localhost:4567`

This setup allows you to:
- Edit Ruby code and see changes immediately without rebuilding containers
- Use your local Ruby development tools (debuggers, linters, etc.)
- Test changes quickly in the browser interface
- Keep other required services running in containers

### Local Development with Containers
When developing locally while using container features:
- **Ruby container**: Can be stopped to use local Ruby environment
- **Other containers**: Must remain running for apps that depend on them
- **Python container**: Required for apps like Concept Visualizer and Syntax Tree that use LaTeX
- **Paths**: Automatically adjusted via `IN_CONTAINER` environment variable

### Testing Apps with Container Dependencies
For apps that require specific containers (e.g., Concept Visualizer needs Python container for LaTeX):
1. Ensure required containers are running: `./docker/monadic.sh check`
2. If developing locally, stop only the Ruby container
3. Run your local Ruby code - it will communicate with other running containers
4. Container paths (`/monadic/data`) are automatically mapped to host paths (`~/monadic/data`)

### Docker Compose Project Consistency
When working with Docker Compose commands, always use the project name flag to ensure consistency:
```bash
docker compose -p "monadic-chat" [command]
```
This is especially important for packaged Electron apps to maintain proper container management.

## For Users

Users who want to customize their containers should place custom scripts in:
- `~/monadic/config/pysetup.sh` for Python customizations
- `~/monadic/config/rbsetup.sh` for Ruby customizations
- `~/monadic/config/olsetup.sh` for Ollama model installations

These user-provided scripts will be automatically used when building containers locally, replacing the placeholder scripts during the build process. However, they won't be committed to the Git repository.