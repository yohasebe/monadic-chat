# Basic Architecture

Monadic Chat provides advanced features that cannot be achieved with just the language model API by incorporating a virtual environment built as a Docker container into the system.

Both users and AI agents can access the Docker container, allowing them to collaborate through natural language communication to bring about changes in the environment. Specifically, under the user's instructions, the AI agent can install commands, learn how to use them, execute commands, and return results.

It also provides a mechanism for sharing data between the host computer and individual Docker containers. This allows users to seamlessly collaborate with the virtual environment, providing necessary files to the AI agent and retrieving files generated by the AI agent.

![Basic Architecture](../assets/images/basic-architecture.png ':size=800')

## Server and Standalone Modes

Monadic Chat can operate in two primary modes:

### Standalone Mode
- Default operating mode
- All components run on a single machine
- Docker containers, web server, and UI are on the same device
- Network bindings use `127.0.0.1` (localhost) for enhanced security
- Only accessible from the device it runs on
- All features including Jupyter Notebook are available

### Server Mode
- Enables multiple clients to connect to a central server
- Server hosts Docker containers and web services
- Clients connect through their web browsers
- Network bindings use `0.0.0.0` (all network interfaces)
- Network URLs use the server's external IP address
- Enables sharing resources across multiple users
- Jupyter-related features are disabled for security reasons

>! **Security Warning**: When exposing Monadic Chat in Server Mode to external networks, especially the internet, implement appropriate security measures such as firewalls, reverse proxies, and authentication mechanisms. The default configuration has no built-in authentication, so it should only be used on trusted networks or with additional security layers.

To switch between modes in the desktop application:

1. Click on the settings icon in the top-right corner
2. Choose either "Standalone Mode" or "Server Mode"
3. Save and restart the application when prompted

To enable Server Mode when running from source code, set the environment variable `DISTRIBUTED_MODE=server` when starting Monadic Chat.

## Standard Docker Containers

This section explains the standard Docker containers available in Monadic Chat. By default, the following containers are built:

### Ruby Container (`monadic-chat-ruby-container`)
This container is necessary to run Monadic Chat applications. It is also used to provide the web interface.
- **Port**: 4567 (Web interface)
- **Main features**: Sinatra web server, WebSocket support, Docker management
- **Shared volumes**: `/monadic/data`, `/monadic/config`, `/monadic/log`

### Python Container (`monadic-chat-python-container`)
This container is used to run Python scripts that extend the functionality of Monadic Chat. JupyterLab also runs on this container.
- **Ports**: 
  - 8889 (JupyterLab)
  - 5070 (Flask API server for tokenization and other services)
- **Main features**: Python code execution, JupyterLab, Flask API server, LaTeX support (for diagram generation)
- **Apps that use this container**: `Code Interpreter`, `Jupyter Notebook`, `Video Describer`, `Syntax Tree`, `Concept Visualizer`

### Selenium Container (`monadic-chat-selenium-container`)
This container is used to operate a virtual web browser using Selenium for web scraping.
- **Ports**: 4444, 5900, 7900 (Selenium Grid)
- **Main features**: Chrome browser automation, web scraping
- **Apps that use this container**: `Code Interpreter`, `Content Reader`, `Mermaid Grapher`

### pgvector Container (`monadic-chat-pgvector-container`)
This container is used to store text embedding vector data on PostgreSQL for using pgvector.
- **Port**: No exposed ports (internal use only)
- **Main features**: Vector similarity search, PDF content storage
- **Apps that use this container**: `PDF Navigator`


You can install new software on a Docker container or edit files to extend the functionality of Monadic Chat.
For more information on adding Docker containers, see [Adding Docker Containers](../advanced-topics/adding-containers.md).

## Optional Docker Containers

In addition to the standard containers, Monadic Chat supports optional containers provided via plugins:

- **Ollama Container** (`monadic-chat-ollama-container`): Provides local LLMs via [Ollama](https://ollama.com) through the Monadic Chat Extra plugin. See [Using Ollama](../advanced-topics/ollama.md) for setup instructions.

## Container Network Architecture

All containers communicate through a shared Docker network:

### Network Configuration
- **Network name**: `monadic-chat-network`
- **Network driver**: Bridge
- **Inter-container communication**: Enabled using container names as hostnames

### Container Dependencies and Startup Order
1. **pgvector** starts first (provides database services)
2. **Selenium** starts next (provides browser automation)
3. **Python** starts after Selenium (may use Selenium for certain operations)
4. **Ruby** starts last (depends on pgvector with health check, and Python)

This startup order ensures all required services are available when dependent containers start.

### Shared Data Volumes
All containers share access to:
- **User data**: `~/monadic/data` (mounted as `/monadic/data` in containers)
- **Configuration**: Ruby container has exclusive access to `/monadic/config`
- **Logs**: Ruby container has exclusive access to `/monadic/log`

## Container Rebuilding Process

When the application is updated, Monadic Chat intelligently determines which containers need to be rebuilt:

1. For new installations, all containers are built from scratch
2. On version updates:
   - The system checks if Dockerfiles for Python, Selenium, and PGVector containers have changed
   - If changes are detected, a full rebuild of all containers is performed
   - If no changes are detected, only the Ruby container is rebuilt

This optimized rebuilding process saves time during updates when only Ruby code has changed, which is the most common update scenario.