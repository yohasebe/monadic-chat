# Jupyter Notebook アーキテクチャドキュメント

## 概要

このドキュメントは、Monadic Chatにおける異なるAIプロバイダー間でのJupyter Notebook統合のアーキテクチャと実装パターンを説明します。

## 主要なアーキテクチャ決定：MonadicモードとNon-Monadicモード

### 課題

異なるAIプロバイダーは、会話コンテキストを維持するための異なるアプローチを持っています：
- **Monadicモード**：自然に状態を保持する構造化JSONレスポンス
- **Non-Monadicモード**：本質的にコンテキストを維持しない自然言語レスポンス

### プロバイダー設定

| プロバイダー | Monadicモード | 理由 |
|----------|--------------|--------|
| OpenAI | `true` | JSON構造とツール実行の両方をサポート |
| Claude | `false` | 思考ブロックがJSON構造と競合 |
| Gemini | `false` | 関数呼び出しまたは構造化出力のいずれかを選択する必要がある |
| xAI Grok | `false` | ツール実行でmonadicモードを使用できない |

## セッションコンテキスト管理

### 問題（2025-08-28発見）

Non-monadicプロバイダー（Claude、Gemini、Grok）は次のような問題を経験していました：
1. ユーザーがノートブックを作成（例：`math_notebook_20250828_123456`）
2. ユーザーがノートブックにセルを追加するように依頼
3. AIが既存のノートブックに追加する代わりに新しいノートブックを作成
4. 根本原因：セッションコンテキスト追跡の指示が欠落

### 解決策

#### Monadicプロバイダー（OpenAI）の場合

特別な処理は不要です。JSON構造が自動的に維持します：
```json
{
  "context": {
    "current_notebook": "math_notebook_20250828_123456",
    "imported_modules": ["numpy", "matplotlib"],
    "defined_functions": ["calculate_derivative", "plot_graph"]
  }
}
```

#### Non-Monadicプロバイダー（Claude、Gemini、Grok）の場合

システムプロンプトで明示的に指示する必要があります：

```markdown
## セッションコンテキスト追跡（重要）

会話セッション全体を通じて、次のことを行う必要があります：
1. **作業中の現在のノートブックファイル名を記憶する**（タイムスタンプを含む）
2. **セル間で使用されるすべての変数、関数、モジュールを追跡する**
3. **ノートブックの状態を認識し続ける**（どのセルが存在するか、何がインポートされたか）
4. ユーザーがさらにセルを追加するように依頼した場合は、以前の同じノートブックファイル名を使用
5. 明示的に要求されない限り、新しいノートブックを作成しない

会話フローの例：
- ユーザー：「数学ノートブックを作成」→ あなたは"math_notebook_20250828_123456"を作成
- ユーザー：「微分を計算する関数を追加」→ "math_notebook_20250828_123456"でadd_jupyter_cellsを使用
- ユーザー：「今度は積分関数を追加」→ まだ"math_notebook_20250828_123456"を使用
```

## プロバイダー固有の実装

### OpenAI
- **ファイル**：`jupyter_notebook_openai.mdsl`
- **Monadic**：`true`
- **コンテキスト追跡**：JSON構造を介して自動
- **特別な処理**：不要

### Claude
- **ファイル**：`jupyter_notebook_claude.mdsl`
- **Monadic**：`false`
- **コンテキスト追跡**：明示的な指示：「セッション全体で使用される変数、関数、モジュールを追跡する」
- **特別な処理**：API呼び出しを減らすためのバッチ処理

### Gemini
- **ファイル**：`jupyter_notebook_gemini.mdsl`
- **Monadic**：`false`
- **コンテキスト追跡**：明示的な指示を追加（2025-08-28）
- **特別な処理**：
  - 初期作成のための結合関数`create_and_populate_jupyter_notebook`
  - 1ターンで複数の連続関数呼び出しを行うことができない

### xAI Grok
- **ファイル**：`jupyter_notebook_grok.mdsl`
- **Monadic**：`false`
- **コンテキスト追跡**：明示的な指示を追加（2025-08-28）
- **特別な処理**：各レスポンスの最後にステータスブロックが必要

## 共通パターン

### ファイル名処理

すべてのプロバイダーは、タイムスタンプ付きファイル名を正しく処理する必要があります：
```
create_jupyter_notebook("math_notebook")
→ 返す："math_notebook_20250828_123456.ipynb"
→ 後続の操作には："math_notebook_20250828_123456"を使用する必要がある
```

### セル構造

すべてのプロバイダー間で標準のセル形式：
```json
{
  "cell_type": "code" | "markdown",
  "source": "コードまたはMarkdownコンテンツ"
}
```

### エラー処理

無限ループを防ぐために最大3回の再試行：
1. `get_jupyter_cells_with_results`で現在のセル状態をチェック
2. `delete_jupyter_cell`で問題のあるセルを削除
3. `add_jupyter_cells`で修正版を追加

## テストの考慮事項

### 主要なテストシナリオ

1. **初期作成**：セル付きでノートブックを作成できる
2. **後続の追加**：既存のノートブックにセルを追加できる
3. **コンテキスト保持**：インポートと変数を記憶する
4. **エラー回復**：セル実行エラーを優雅に処理する

### プロバイダー固有のテスト

- `spec/integration/jupyter_notebook_openai_spec.rb`
- `spec/integration/jupyter_notebook_claude_spec.rb`
- `spec/integration/jupyter_notebook_gemini_spec.rb`
- `spec/integration/jupyter_notebook_grok_spec.rb`

## 学んだ教訓

1. **明示的が優れている**：Non-monadicプロバイダーには明示的なコンテキスト追跡指示が必要
2. **プロバイダーの制限**：一部のプロバイダー（Gemini）は複数のツール呼び出しを連鎖できない
3. **回避策**：結合関数は連続呼び出しの制限を克服できる
4. **テストが重要**：セッションコンテキストの問題はマルチターン会話でのみ現れる

## 将来の改善

1. **統合コンテキストマネージャー**：Non-monadicプロバイダー向けの共有コンテキスト管理システムを作成
2. **自動フォールバック**：コンテキストが失われたときを検出し、自動的に回復
3. **セッション永続性**：セッション間でノートブックコンテキストを保存
4. **プロバイダー抽象化**：共通のインターフェースの背後にプロバイダー固有の癖を隠す
