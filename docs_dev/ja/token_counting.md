# トークンカウンティング戦略（内部向け）

このドキュメントは、トークンカウンティングの内部ポリシーと、プロバイダー報告された使用量との相互作用について説明します。

## 目標
- モデル固有のコンテキストウィンドウと`max_tokens`制限に対する安全な送信前コンテキスト整形を保証する。
- UIで安定した一貫性のあるトークン統計を提供する。
- 不必要な複雑さと運用上の脆弱性を回避する。

## ポリシー

責任を2つのレイヤーに分割します：

1) 送信前コンテキスト整形（権威的）
   - 統一トークナイザーパイプライン（Flaskサービス経由のtiktoken）を使用。
   - SSOT（コンテキストウィンドウ、安全マージン、予約出力トークン、プロバイダー固有のオーバーヘッド）からモデルごとの制約を適用し、送信前に古いメッセージをドロップまたは切り詰める。
   - 理由：これはプロバイダー側のエラーを防ぐために、決定論的で制御下にある必要がある安全ゲートです。

2) 送信後統計（オプション）
   - UIで最新ターンのプロバイダー報告使用量（入力/出力）を表示できます。通常は請求と密接に一致します。
   - 混乱を避け、トークン数の単一の情報源を保証するため、デフォルトでは無効になっています。`TOKEN_COUNT_SOURCE`で有効化できます。

## 設定

- `TOKEN_COUNT_SOURCE`
  - デフォルト：`python_only`
  - 値：
    - `python_only`：常にカウントにtiktoken/Flaskを使用（推奨）。
    - `provider_only`または`hybrid`：最新ターンにプロバイダー報告使用量の使用を許可（利用可能な場合）。ハイブリッドは送信前整形にtiktoken/Flaskに依存します。

## 理由とトレードオフ
- プロバイダー使用量は表示には優れていますが、多くの場合、役割ごとの粒度が欠けており、すべてのストリーミングモードで利用できるわけではありません。したがって、プロバイダー使用量をオプションの拡張として保持し、権威的なパスにはtiktokenを保持します。
- これにより、複雑さが低く保たれ、安全性が確保され、ユーザーに表示される不整合が回避されます。

## 実装者向けノート
- 送信前整形にプロバイダー使用量のみに依存しないでください。
- プロバイダー使用量からメッセージごとの`tokens`を設定するコードパスは、オーバーライドを適用する前に`TOKEN_COUNT_SOURCE`フラグをチェックする必要があります。
- インポート/エクスポート：メッセージには`tokens`フィールドが含まれる場合があります。存在する場合は保持します。

## 将来の作業（オプション）
- プロバイダーのカウントエンドポイントが送信前整形に使用される高精度モード（Anthropic/Gemini/Cohere/Mistral）を追加し、フォールバックとしてtiktokenを使用します。これは意図的にデフォルトではありません。
