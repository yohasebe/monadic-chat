# TTS事前取得最適化

## 概要

テキスト読み上げ（TTS）のパフォーマンスは、現在のセグメントが再生されている間に次のテキストセグメントのオーディオを生成する事前取得パイプラインを使用して最適化されています。これにより、待機時間が大幅に短縮され、ユーザーエクスペリエンスが向上します。

## 実装詳細

**場所：** `docker/services/ruby/lib/monadic/utils/websocket.rb`（PLAY_TTSハンドラー、約1452-1670行）

### 事前取得の仕組み

1. **テキストセグメンテーション**：テキストは`PragmaticSegmenter`を使用して文に分割されます
2. **並列処理**：最大2つのTTS APIリクエストが同時に実行されます
3. **パイプライン実行**：
   - セグメント0と1のAPIリクエストを開始
   - セグメント0が再生されている間、セグメント1が生成されています
   - セグメント1の再生が開始されると、セグメント2の生成が始まります
   - すべてのセグメントが処理されるまで継続

### メリット

- **再生開始の高速化**：最初のセグメントが準備でき次第すぐに再生
- **シームレスな移行**：現在のセグメントが終了するまでに次のセグメントが準備完了
- **最適化されたリソース使用**：レート制限を避けるために2つの同時リクエストのみ

## プロバイダー固有の動作

### ElevenLabs（Flash、Multilingual、V3）

- **セグメンテーション**：文で分割
- **事前取得**：有効（2つの同時リクエスト）
- **コンテキスト連続性**：APIパラメータ経由でサポート
  - `previous_text`：✅ Monadic Chatで実装済み（`interaction_utils.rb:371-373`）
  - `next_text`：⚠️ APIでサポートされているが未実装
  - セグメント全体でより良い音声連続性を提供

### OpenAI TTS（Standard、HD、4o Mini）

- **セグメンテーション**：文で分割
- **事前取得**：有効（2つの同時リクエスト）
- **コンテキスト連続性**：❌ 利用不可（APIはコンテキストパラメータをサポートしていません）

### Gemini TTS（Flash、Pro）

- **セグメンテーション**：文で分割（最小長検証付き）
- **事前取得**：有効（2つの同時リクエスト）
- **コンテキスト連続性**：❌ パラメータ経由では利用不可
  - 代わりにセッションレベルのコンテキスト（32kトークンウィンドウ）を使用
  - スタイルプロンプトがトーン/配信コントロールを提供

### ElevenLabs V3固有の動作

**デフォルト動作（事前取得有効）：**
- セグメントは事前取得の利点のために分割されます
- 再生開始が高速
- 設定：不要（デフォルト）

**レガシー動作（オプション）：**
- すべてのテキストを単一のセグメントに結合
- 再生開始が遅い（テキスト全体を待機）
- 設定：`~/monadic/config/env`で`ELEVENLABS_V3_COMBINE_SEGMENTS=true`を設定

**なぜV3は最初は異なっていたか：**
ElevenLabs V3はもともと最適な品質のためにすべてのテキストを一度に処理するように設計されていました。しかし、これは事前取得の利点がないことを意味しました。新しいデフォルト動作は品質を維持しながら事前取得を有効にします。

### Web Speech API

- **処理**：クライアント側（ブラウザネイティブ）
- **事前取得**：該当なし（API呼び出しなし）
- **パフォーマンス**：即座（ネットワーク遅延なし）

### Gemini TTS

- **特別な処理**：短いセグメントはAPI失敗を避けるために結合されます
- **最小長**：8文字（クリーンされたテキスト）
- **事前取得**：結合されたセグメントで有効

## コード簡素化と品質改善（2025-10-14）

### Gemini TTSエンドポイント最適化

**問題：** Gemini TTSは複雑なストリーミングロジック（80行以上）で`streamGenerateContent`エンドポイントを使用していましたが、APIは1つのレスポンスで完全なオーディオを返します。

**解決策：**
- すべてのリクエストで`generateContent`エンドポイントに変更
- 不要なストリーミング固有のコードを削除（80行）
- 標準の非ストリーミングレスポンス処理と統一

**結果：**
- レイテンシの改善なし（API側のボトルネックを確認）
- 大幅にクリーンなコードベース
- より良い保守性
- 実際のAPI動作と一貫性

**場所：** `docker/services/ruby/lib/monadic/utils/interaction_utils.rb`（約453-507行）

### OpenAI TTSオーディオ品質改善

**問題：** ユーザーが速度を変更していない場合（デフォルト`speed=1.0`）でも、`speed`パラメータが常にOpenAI APIに送信されていました。これにより速度変換処理が強制され、特に`gpt-4o-mini-tts`でオーディオ品質が低下していました。

**根本原因：**
```ruby
# 以前（問題）
val_speed = speed ? speed.to_f : 1.0  # 常に1.0に設定
body = {
  "speed" => val_speed,  # デフォルト速度でも常に送信
  ...
}
```

**解決策：**
- ユーザーによって明示的に設定され、1.0と異なる場合のみ`speed`パラメータを含める
- ユーザーが速度を変更していない場合は`speed`パラメータを省略
- OpenAIが速度変換のオーバーヘッドなしで最適な処理を使用できるようにする

```ruby
# 後（改善）
body = {
  "input" => text_converted,
  "model" => model,
  "voice" => voice,
  "response_format" => response_format
}

# ユーザーが明示的に設定した場合のみspeedパラメータを含める
if speed && speed.to_f != 1.0
  body["speed"] = speed.to_f
end
```

**結果：**
- **顕著なオーディオ品質改善**（主観的評価で確認）
- gpt-4o-mini-ttsがデフォルト速度でより高品質な出力を生成
- ElevenLabs実装パターンと一貫性（必要な場合のみ送信）
- ユーザーが積極的に速度を調整する場合の速度制御に機能的な変更なし

**影響：**
- デフォルトTTS（速度変更なし）：より良い品質、`speed`パラメータ未送信
- 速度調整（例：0.5x、1.5x）：以前と同様に動作、`speed`パラメータ送信

**場所：** `docker/services/ruby/lib/monadic/utils/interaction_utils.rb`（約323-327行）

## 安全性の改善（2025-10-12追加）

### 1. STOP_TTSスレッドクリーンアップ

**問題：** TTSの停止はメインスレッドのみを終了し、事前取得APIリクエストスレッドが実行されたままでした。

**解決策：**
- `Thread.current[:tts_futures]`に`tts_futures`配列を保存
- STOP_TTSハンドラーはメインスレッドを終了する前にすべての事前取得サブスレッドを終了
- 孤立したスレッドと無駄なAPI呼び出しを防止

**場所：** 1424-1451行、1567-1568行

### 2. Thread#valueのエラーハンドリング

**問題：** 単一のセグメント失敗が再生全体を停止していました。

**解決策：**
- `Thread#value`を`begin/rescue`ブロックでラップ
- 失敗したセグメントのエラーレスポンスを作成
- 1つが失敗しても次のセグメントに続行
- APIエラーとスレッド終了例外の両方を処理

**場所：** 1603-1615行

### 3. グレースフルデグラデーション

**動作：**
- セグメントNが失敗しても、セグメントN+1は再生されます
- ユーザーはログでどのセグメントが失敗したかを確認できます
- STOP_TTSは事前取得パイプラインをクリーンに中断

## 設定オプション

### ~/monadic/config/env

```bash
# ElevenLabs V3セグメント動作（オプション）
ELEVENLABS_V3_COMBINE_SEGMENTS=true  # 事前取得を無効化（レガシーモード）

# TTS+テキスト配信のバッチ処理（オプション）
USE_BATCH_PROCESSING=false           # バッチングを無効化

# デバッグロギング（オプション）
EXTRA_LOGGING=true                   # 詳細ログを有効化
```

## デバッグロギング

`EXTRA_LOGGING=true`の場合、以下が表示されます：

```
ElevenLabs V3: Using segment splitting for prefetch (5 segments)
TTS segment 2 failed with exception: Connection timeout
ElevenLabs V3: Combined all segments into one (legacy mode)
```

## パフォーマンス特性

### 事前取得なし（レガシーV3）
- 待機時間：完全なテキスト生成時間
- 例：30秒のテキスト → 30秒待機 → 再生開始

### 事前取得あり（新デフォルト）
- 待機時間：最初のセグメント生成時間のみ
- 例：30秒のテキスト → 3秒待機 → 再生開始（残りのセグメントは再生中に生成）

### 典型的な改善
- **最初のオーディオまでの時間**：長いテキストで5-10倍高速
- **体感レイテンシ**：劇的に削減
- **ユーザーエクスペリエンス**：ほぼ瞬時に感じる

## パフォーマンスベンチマーク結果（2025-10-14）

すべてのプロバイダーにわたる116文字のテストテキストの包括的なレイテンシ測定：

### TTFB（Time to First Byte）ランキング：
1. **ElevenLabs Flash：532.5ms** ⚡ 最速
2. **OpenAI TTS HD：1334.3ms**（驚くほど標準より高速）
3. **OpenAI TTS：1913.4ms**
4. **Gemini Flash TTS：6129.8ms**（ElevenLabsより11.5倍遅い）

### 合計完了時間：
1. **ElevenLabs Flash：603.2ms** - 最速のエンドツーエンド
2. **OpenAI TTS HD：1814.3ms**
3. **OpenAI TTS：3038.9ms**
4. **Gemini Flash TTS：6253.9ms**

### オーディオファイルサイズ：
1. **ElevenLabs Flash：95.6 KB** - 最小、最適化された圧縮
2. **OpenAI TTS：139.7 KB**
3. **OpenAI TTS HD：140.6 KB** - 最小限のサイズ増加でHD品質
4. **Gemini Flash TTS：561.4 KB** - ElevenLabsの6倍

### 主要な洞察：

**ElevenLabs Flash（低レイテンシに最適）：**
- 最速のTTFBと合計時間
- 最小のファイルサイズ
- リアルタイム会話アプリケーションに最適
- 名前がパフォーマンスを正確に反映（「Flash」）

**OpenAI TTS 4o Mini（gpt-4o-mini-tts）：**
- 最新で最も有能なTTSモデル（ベンチマーク：1644ms TTFB）
- OpenAIモデルの中で**最小のファイルサイズ**：117.4 KB
- 細かい制御のための`instructions`パラメータをサポート（アクセント、感情、トーン、速度、ささやきなど）
- 例：`"instructions": "Speak in a cheerful and positive tone."`
- 11の音声：alloy、ash、ballad、coral、echo、fable、nova、onyx、sage、shimmer（5つの新しい音声を追加）
- **フォーマット推奨**：最速のレスポンス時間には`wav`または`pcm`を使用（OpenAIドキュメントによる）
- **品質改善**：`speed`パラメータはユーザーが速度を変更した場合のみ送信（デフォルト品質の向上）
- TTS HDより高速（1644ms vs 1795ms）
- 品質とインストラクション制御の両方が必要な場合に最適

**OpenAI TTS HD（最良のバランス）：**
- 標準モデルより高速（直感に反する！）
- 最小限のレイテンシペナルティでより良い品質
- 一般的な使用には標準TTSモデルより推奨

**OpenAI TTS（標準）：**
- **パフォーマンスが大幅に変動**（810-1913ms TTFBを観察）
- より多くのストリーミングチャンク（313-324）は、より細かいストリーミングを示す
- API側のロードバランシングにより、HDより高速な場合がある
- OpenAI APIのパフォーマンスはサーバー負荷とルーティングに依存

**Gemini Flash TTS（速度より品質）：**
- 大幅に遅い（6-7秒の初期待機）
- はるかに大きいファイルサイズ（561-579 KB）
- 「Flash」の名前はTTSパフォーマンスに誤解を招く
- レイテンシより品質が重要な場合に最適
- 事前取得最適化はこのプロバイダーにとって最も重要
- **調査（2025-10-14）：** `streamGenerateContent`と`generateContent`の両方のエンドポイントをテスト - レイテンシ不変（約6-7秒）、API側のボトルネックを確認

### 事前取得の影響：
- これらの測定は単一セグメントテキスト（116文字）用です
- マルチセグメントテキストは事前取得からはるかに多くの恩恵を受けます
- Geminiの6秒待機は長いテキストの事前取得によって隠すことができます
- ElevenLabsは事前取得なしでもすでに瞬時に感じます

### 推奨事項：
- **絶対最速**：ElevenLabs Flash（580ms TTFB、108 KB）
- **インストラクションに最適**：OpenAI TTS 4o Mini（1644ms TTFB、117 KB、完全なプロンプト制御）
- **最良のバランス**：OpenAI TTS HD（1795ms TTFB、より良いオーディオ品質）
- **バジェットオプション**：OpenAI TTS Standard（810-1913ms、パフォーマンスは変動）
- **高品質**：Gemini（6-7s TTFB、559 KB、レイテンシのトレードオフを受け入れる）
- **最速フォーマット**：`wav`または`pcm`を使用（OpenAIが最低レイテンシに推奨）
- **事前取得を有効化**：Geminiには重要、すべてのプロバイダーに有益

### パフォーマンスノート：
- OpenAI APIレイテンシは負荷に応じて2-3倍変動（観察：同じモデルで810msから1913ms）
- 最初のベンチマークセッションは通常、後続の実行とは異なるパターンを示す
- ElevenLabs Flashは一貫して最速で最も予測可能なレイテンシを提供
- Gemini TTSレイテンシはエンドポイントに関係なく不変（`streamGenerateContent` vs `generateContent`）

### ユースケース別のフォーマット選択：
- **最低レイテンシ**：`wav`または`pcm`（デコードオーバーヘッドなし）
- **一般使用**：`mp3`（デフォルト、良いバランス）
- **インターネットストリーミング**：`opus`（低レイテンシストリーミング用に最適化）
- **モバイルアプリ**：`aac`（iOS/Androidで優先）
- **アーカイブ**：`flac`（ロスレス圧縮）

## テスト

以下でテスト済み：
- ✅ OpenAI TTS（`tts-1`、`tts-1-hd`）
- ✅ Google Cloud TTS（複数の音声）
- ✅ ElevenLabs V3（新しい事前取得モード）
- ✅ Gemini TTS（`gemini-flash`、`gemini-pro`）

ベンチマークスクリプト：`tmp/test_all_tts_latency.rb`

## 既知の制限

1. **メモリ使用量**：多くのセグメントを持つ長いテキストはメモリを消費（2リクエスト制限で緩和）
2. **APIレート制限**：非常に頻繁なリクエストで可能性あり（2同時では unlikely）
3. **ElevenLabs V3**：一部のユーザーは品質の理由でレガシー単一リクエストモードを好む可能性がある

## 将来の改善

- [ ] セグメント長に基づく適応的同時実行性
- [ ] プロバイダー固有の最適化（例：V3品質vs速度のトレードオフ）
- [ ] メモリ使用量の監視と自動スロットリング
- [ ] 頻繁に使用されるテキストセグメントのキャッシング

## 関連ファイル

- `docker/services/ruby/lib/monadic/utils/websocket.rb` - メイン実装
- `docker/services/ruby/apps/*/` - TTS機能を使用するアプリ
- `docker/services/ruby/public/js/monadic/ui/audio_player.js` - クライアント側再生

## 関連項目

- `docs_dev/websocket_progress_broadcasting.md` - WebSocket通信パターン
- `docs/features/text-to-speech.md` - ユーザー向けTTSドキュメント
