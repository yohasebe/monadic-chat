// audio context
let audioCtx = null;


// Assuming 'audio' is a global variable that holds the current Audio instance
let speechQueue = [];

function ttsSpeak(text, stream, callback) {
  // Queue the speech

  if (!audio) {
    audio = new Audio();
    audio.src = URL.createObjectURL(mediaSource);
    audio.load();
  }

  speechQueue.push({text, stream, callback});
  // wait for audio to pause in a loop and then process the next item in the queue
  if audio.paused {
    processNextSpeech();
  } else {
    audio.onpause = processNextSpeech;
  }
}

function processNextSpeech() {
  if (speechQueue.length > 0) {
    const {text, stream, callback} = speechQueue.shift();
    speakProcess(text, stream, () => {
      if (callback) callback();
      // Process the next item in the queue
      processNextSpeech();
    });
  }
}

function speakProcess(text, stream, callback) {

  if(stream){
    ttsStop();
  }

  if (!audioCtx) {
    audioCtx = new AudioContext();
  }

  if (audioCtx.state === 'suspended') {
    audioCtx.resume().then(() => {
      console.log('AudioContext resumed successfully');
      // After ensuring the AudioContext is active, proceed with playing the audio
      playAudio(text, stream, callback);
    });
  } else {
    // If the AudioContext is already running, proceed with playing the audio
    playAudio(text, stream, callback);
  }
}

function playAudio(text, stream, callback) {
  // Move the audio playing logic here
  let playPromise = audio.play();
  if (playPromise !== undefined) {
    playPromise.then(_ => {
      // When audio finishes playing, call the callback to indicate speech is done
      if (callback) callback();
    }).catch(error => {
      console.error("Error playing audio:", error);
      if (callback) callback(); // Ensure callback is called even on error
    });
  } else {
    // Directly call callback if playPromise is undefined
    if (callback) callback();
  }

  if (runningOnFirefox) {
    return false;
  }

  if (!text) {
    return;
  }

  // const quality = $("#tts-quality").is(":checked");
  const voice = $("#tts-voice").val();
  const speed = parseFloat($("#tts-speed").val());

  let mode = "TTS"

  if(stream){
    mode = "TTS_STREAM"
  }

  let model = "tts-1"
  // if (quality) {
  //   model = "tts-1-hd"
  // }

  let response_format = "mp3"
  if(runningOnFirefox){
    response_format = "mp3"
  }

  ws.send(JSON.stringify({
    message: mode,
    text: text,
    voice: voice,
    speed: speed,
    model: model,
    response_format: response_format
  }));
}

function ttsStop() {
  speechQueue = []; // Optionally clear the queue

  if (audio) {
    // audio.pause();
    audio = null;
  }

  // sourceBuffer = null;
  audioDataQueue = [];

  mediaSource = new MediaSource();
  mediaSource.addEventListener('sourceopen', () => {
    console.log('MediaSource opened');
    if (runningOnFirefox) {
      sourceBuffer = mediaSource.addSourceBuffer('audio/mp4; codecs="mp3"');
    } else {
      sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg');
    }
    sourceBuffer.addEventListener('updateend', processAudioDataQueue);
  });

  audio = new Audio();
  audio.src = URL.createObjectURL(mediaSource);
  audio.load();
}
